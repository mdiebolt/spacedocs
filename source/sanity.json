[{"Array#":{"method_list":["average","compact","copy","clear","flatten","invoke","rand","remove","include","each","map","eachPair","eachWithObject","eachSlice","pipeline","shuffle","first","last","extremes","wrap","partition","select","without","reject","inject","sum","product","zip","pop","push","reverse","shift","sort","splice","unshift","concat","join","slice","toString","indexOf","lastIndexOf","filter","forEach","every","some","reduce","reduceRight"],"methods":{"average":{"summary":"<p>Calculate the average value of an array. Returns undefined if some elements<br />are not numbers.</p>","code_sample":"<pre><code>[1, 3, 5, 7].average()\n# =&gt; 4\n</code></pre>","source":"var _base,\n  __slice = Array.prototype.slice;\n\nArray.prototype.average = function() {\n  return this.sum() / this.length;\n};","parameters":{},"returns":{"type":"Number","description":"The average (arithmetic mean) of the list of numbers."},"see":""},"compact":{"summary":"<p>Returns a copy of the array without null and undefined values.</p>","code_sample":"<pre><code>[null, undefined, 3, 3, undefined, 5].compact()\n# =&gt; [3, 3, 5]\n</code></pre>","source":"Array.prototype.compact = function() {\n  return this.select(function(element) {\n    return element != null;\n  });\n};","parameters":{},"returns":{"type":"Array","description":"A new array that contains only the non-null values."},"see":""},"copy":{"summary":"<p>Creates and returns a copy of the array. The copy contains<br />the same objects.</p>","code_sample":"<pre><code>a = [\"a\", \"b\", \"c\"]\nb = a.copy()\n\n# their elements are equal\na[0] == b[0] &amp;&amp; a[1] == b[1] &amp;&amp; a[2] == b[2]\n# =&gt; true\n\n# but they aren't the same object in memory\na === b\n# =&gt; false\n</code></pre>","source":"Array.prototype.copy = function() {\n  return this.concat();\n};","parameters":{},"returns":{"type":"Array","description":"A new array that is a copy of the array"},"see":""},"clear":{"summary":"<p>Empties the array of its contents. It is modified in place.</p>","code_sample":"<pre><code>fullArray = [1, 2, 3]\nfullArray.clear()\nfullArray\n# => []</code></pre>","source":"Array.prototype.clear = function() {\n  this.length = 0;\n  return this;\n};","parameters":{},"returns":{"type":"Array","description":"this, now emptied."},"see":""},"flatten":{"summary":"<p>Flatten out an array of arrays into a single array of elements.</p>","code_sample":"<pre><code>[[1, 2], [3, 4], 5].flatten()\n# =&gt; [1, 2, 3, 4, 5]\n\n# won't flatten twice nested arrays. call\n# flatten twice if that is what you want\n[[1, 2], [3, [4, 5]], 6].flatten()\n# =&gt; [1, 2, 3, [4, 5], 6]\n</code></pre>","source":"Array.prototype.flatten = function() {\n  return this.inject([], function(a, b) {\n    return a.concat(b);\n  });\n};","parameters":{},"returns":{"type":"Array","description":"A new array with all the sub-arrays flattened to the top."},"see":""},"invoke":{"summary":"<p>Invoke the named method on each element in the array<br />and return a new array containing the results of the invocation.</p>","code_sample":"<pre><code>[1.1, 2.2, 3.3, 4.4].invoke(\"floor\")\n# =&gt; [1, 2, 3, 4]\n\n['hello', 'world', 'cool!'].invoke('substring', 0, 3)\n# =&gt; ['hel', 'wor', 'coo']\n</code></pre>","source":"Array.prototype.invoke = function() {\n  var args, method;\n  method = arguments[0], args = 2 <= arguments.length ? __slice.call(arguments, 1) : [];\n  return this.map(function(element) {\n    return element[method].apply(element, args);\n  });\n};","parameters":{"method":{"type":"String","description":"The name of the method to invoke.","optional":false},"Optional":{"type":"[arg...]","description":"arguments to pass to the method being invoked.","optional":false}},"returns":{"type":"Array","description":"A new array containing the results of invoking the named method on each element."},"see":""},"rand":{"summary":"<p>Randomly select an element from the array.</p>","code_sample":"<pre><code>[1, 2, 3].rand()\n# =&gt; 2\n</code></pre>","source":"Array.prototype.rand = function() {\n  return this[rand(this.length)];\n};","parameters":{},"returns":{"type":"Object","description":"A random element from an array"},"see":""},"remove":{"summary":"<p>Remove the first occurrence of the given object from the array if it is<br />present. The array is modified in place.</p>","code_sample":"<pre><code>a = [1, 1, \"a\", \"b\"]\na.remove(1)\n# =&gt; 1\n\na\n# =&gt; [1, \"a\", \"b\"]\n</code></pre>","source":"Array.prototype.remove = function(object) {\n  var index;\n  index = this.indexOf(object);\n  if (index >= 0) {\n    return this.splice(index, 1)[0];\n  } else {\n    return;\n  }\n};","parameters":{"object":{"type":"Object","description":"The object to remove from the array if present.","optional":false}},"returns":{"type":"Object","description":"The removed object if present otherwise undefined."},"see":""},"include":{"summary":"<p>Returns true if the element is present in the array.</p>","code_sample":"<pre><code>[\"a\", \"b\", \"c\"].include(\"c\")\n# =&gt; true\n\n[40, \"a\"].include(700)\n# =&gt; false\n</code></pre>","source":"Array.prototype.include = function(element) {\n  return this.indexOf(element) !== -1;\n};","parameters":{"element":{"type":"Object","description":"The element to check if present.","optional":false}},"returns":{"type":"Boolean","description":"true if the element is in the array, false otherwise."},"see":""},"each":{"summary":"<p>Call the given iterator once for each element in the array,<br />passing in the element as the first argument, the index of<br />the element as the second argument, and <code>this</code> array as the<br />third argument.</p>","code_sample":"<pre><code>word = \"\"\nindices = []\n[\"r\", \"a\", \"d\"].each (letter, index) -&gt;\n  word += letter\n  indices.push(index)\n\n# =&gt; [\"r\", \"a\", \"d\"]\n\nword\n# =&gt; \"rad\"\n\nindices\n# =&gt; [0, 1, 2]\n</code></pre>","source":"Array.prototype.each = function(iterator, context) {\n  var element, i, _len;\n  if (this.forEach) {\n    this.forEach(iterator, context);\n  } else {\n    for (i = 0, _len = this.length; i < _len; i++) {\n      element = this[i];\n      iterator.call(context, element, i, this);\n    }\n  }\n  return this;\n};","parameters":{"iterator":{"type":"Function","description":"Function to be called once for each element in the array.","optional":false},"context":{"type":"Object","description":"Optional context parameter to be used as `this` when calling the iterator function.","optional":true}},"returns":{"type":"Array","description":"this to enable method chaining."},"see":""},"map":{"summary":"<p>Creates a new array with the results of calling a provided function on every<br />element in this array.</p>","code_sample":"<p><code><em>array</em>.map(<em>callback</em>[, <em>thisObject</em>])</code></p>","source":null,"parameters":{"Function":{"type":"callbackthisObject","description":"that produces an element of the new Array","optional":false}},"returns":{},"see":""},"eachPair":{"summary":"<p>Call the given iterator once for each pair of objects in the array.</p>","code_sample":"<pre><code>[1, 2, 3, 4].eachPair (a, b) -&gt;\n  # 1, 2\n  # 1, 3\n  # 1, 4\n  # 2, 3\n  # 2, 4\n  # 3, 4\n</code></pre>","source":"Array.prototype.eachPair = function(iterator, context) {\n  var a, b, i, j, length, _results;\n  length = this.length;\n  i = 0;\n  _results = [];\n  while (i < length) {\n    a = this[i];\n    j = i + 1;\n    i += 1;\n    _results.push((function() {\n      var _results2;\n      _results2 = [];\n      while (j < length) {\n        b = this[j];\n        j += 1;\n        _results2.push(iterator.call(context, a, b));\n      }\n      return _results2;\n    }).call(this));\n  }\n  return _results;\n};","parameters":{"iterator":{"type":"Function","description":"Function to be called once for each pair of elements in the array.","optional":false},"context":{"type":"Object","description":"Optional context parameter to be used as `this` when calling the iterator function.","optional":true}},"returns":{},"see":""},"eachWithObject":{"summary":"<p>Call the given iterator once for each element in the array,<br />passing in the element as the first argument and the given object<br />as the second argument. Additional arguments are passed similar to<br /><code>each</code>.</p>","code_sample":"","source":"Array.prototype.eachWithObject = function(object, iterator, context) {\n  this.each(function(element, i, self) {\n    return iterator.call(context, element, object, i, self);\n  });\n  return object;\n};","parameters":{"object":{"type":"Object","description":"The object to pass to the iterator on each visit.","optional":false},"iterator":{"type":"Function","description":"Function to be called once for each element in the array.","optional":false},"context":{"type":"Object","description":"Optional context parameter to be used as `this` when calling the iterator function.","optional":true}},"returns":{"type":"Array","description":"this"},"see":"Array#each"},"eachSlice":{"summary":"<p>Call the given iterator once for each group of elements in the array,<br />passing in the elements in groups of n. Additional argumens are<br />passed as in each.</p>","code_sample":"<pre><code>results = []\n[1, 2, 3, 4].eachSlice 2, (slice) -&gt;\n  results.push(slice)\n# =&gt; [1, 2, 3, 4]\n\nresults\n# =&gt; [[1, 2], [3, 4]]\n</code></pre>","source":"Array.prototype.eachSlice = function(n, iterator, context) {\n  var i, len;\n  if (n > 0) {\n    len = (this.length / n).floor();\n    i = -1;\n    while (++i < len) {\n      iterator.call(context, this.slice(i * n, (i + 1) * n), i * n, this);\n    }\n  }\n  return this;\n};","parameters":{"n":{"type":"Number","description":"The number of elements in each group.","optional":false},"iterator":{"type":"Function","description":"Function to be called once for each group of elements in the array.","optional":false},"context":{"type":"Object","description":"Optional context parameter to be used as `this` when calling the iterator function.","optional":true}},"returns":{"type":"Array","description":"this"},"see":"Array#each"},"pipeline":{"summary":"<p>Pipe the input through each function in the array in turn. For example, if you have a<br />list of objects you can perform a series of selection, sorting, and other processing<br />methods and then receive the processed list. This array must contain functions that<br />accept a single input and return the processed input. The output of the first function<br />is fed to the input of the second and so on until the final processed output is returned.</p>","code_sample":"","source":"Array.prototype.pipeline = function(input) {\n  var fn, _i, _len;\n  for (_i = 0, _len = this.length; _i < _len; _i++) {\n    fn = this[_i];\n    input = fn(input);\n  }\n  return input;\n};","parameters":{"input":{"type":"Object","description":"The initial input to pass to the first function in the pipeline.","optional":false}},"returns":{"type":"Object","description":"The result of processing the input by each function in the array."},"see":""},"shuffle":{"summary":"<p>Returns a new array with the elements all shuffled up.</p>","code_sample":"<pre><code>a = [1, 2, 3]\n\na.shuffle()\n# =&gt; [2, 3, 1]\n\na # =&gt; [1, 2, 3]\n</code></pre>","source":"Array.prototype.shuffle = function() {\n  var shuffledArray;\n  shuffledArray = [];\n  this.each(function(element) {\n    return shuffledArray.splice(rand(shuffledArray.length + 1), 0, element);\n  });\n  return shuffledArray;\n};","parameters":{},"returns":{"type":"Array","description":"A new array that is randomly shuffled."},"see":""},"first":{"summary":"<p>Returns the first element of the array, undefined if the array is empty.</p>","code_sample":"<pre><code>[\"first\", \"second\", \"third\"].first()\n# =&gt; \"first\"\n</code></pre>","source":"Array.prototype.first = function() {\n  return this[0];\n};","parameters":{},"returns":{"type":"Object","description":"The first element, or undefined if the array is empty."},"see":""},"last":{"summary":"<p>Returns the last element of the array, undefined if the array is empty.</p>","code_sample":"<pre><code>[\"first\", \"second\", \"third\"].last()\n# =&gt; \"third\"\n</code></pre>","source":"Array.prototype.last = function() {\n  return this[this.length - 1];\n};","parameters":{},"returns":{"type":"Object","description":"The last element, or undefined if the array is empty."},"see":""},"extremes":{"summary":"<p>Returns an object containing the extremes of this array.</p>","code_sample":"<pre><code>[-1, 3, 0].extremes()\n# =&gt; {min: -1, max: 3}\n</code></pre>","source":"Array.prototype.extremes = function(fn) {\n  var max, maxResult, min, minResult;\n  fn || (fn = function(n) {\n    return n;\n  });\n  min = max = void 0;\n  minResult = maxResult = void 0;\n  this.each(function(object) {\n    var result;\n    result = fn(object);\n    if (min != null) {\n      if (result < minResult) {\n        min = object;\n        minResult = result;\n      }\n    } else {\n      min = object;\n      minResult = result;\n    }\n    if (max != null) {\n      if (result > maxResult) {\n        max = object;\n        return maxResult = result;\n      }\n    } else {\n      max = object;\n      return maxResult = result;\n    }\n  });\n  return {\n    min: min,\n    max: max\n  };\n};","parameters":{"fn":{"type":"Function","description":"An optional funtion used to evaluate each element to calculate its value for determining extremes.","optional":true}},"returns":{"type":"Object","description":"{min: minElement, max: maxElement}"},"see":""},"wrap":{"summary":"<p>Pretend the array is a circle and grab a new array containing length elements.<br />If length is not given return the element at start, again assuming the array<br />is a circle.</p>","code_sample":"<pre><code>[1, 2, 3].wrap(-1)\n# =&gt; 3\n\n[1, 2, 3].wrap(6)\n# =&gt; 1\n\n[\"l\", \"o\", \"o\", \"p\"].wrap(0, 16)\n# =&gt; [\"l\", \"o\", \"o\", \"p\", \"l\", \"o\", \"o\", \"p\", \"l\", \"o\", \"o\", \"p\", \"l\", \"o\", \"o\", \"p\"]\n</code></pre>","source":"Array.prototype.wrap = function(start, length) {\n  var end, i, result;\n  if (length != null) {\n    end = start + length;\n    i = start;\n    result = [];\n    while (i++ < end) {\n      result.push(this[i.mod(this.length)]);\n    }\n    return result;\n  } else {\n    return this[start.mod(this.length)];\n  }\n};","parameters":{"start":{"type":"Number","description":"The index to start wrapping at, or the index of the sole element to return if no length is given.","optional":false},"length":{"type":"Number","description":"Optional length determines how long result array should be.","optional":true}},"returns":{"type":"Object","description":"or {Array} The element at start mod array.length, or an array of length elements, starting from start and wrapping."},"see":""},"partition":{"summary":"<p>Partitions the elements into two groups: those for which the iterator returns<br />true, and those for which it returns false.</p>","code_sample":"<pre><code>[evens, odds] = [1, 2, 3, 4].partition (n) -&gt;\n  n.even()\n\nevens\n# =&gt; [2, 4]\n\nodds\n# =&gt; [1, 3]\n</code></pre>","source":"Array.prototype.partition = function(iterator, context) {\n  var falseCollection, trueCollection;\n  trueCollection = [];\n  falseCollection = [];\n  this.each(function(element) {\n    if (iterator.call(context, element)) {\n      return trueCollection.push(element);\n    } else {\n      return falseCollection.push(element);\n    }\n  });\n  return [trueCollection, falseCollection];\n};","parameters":{"iterator":{"type":"Function","description":"","optional":false},"context":{"type":"Object","description":"Optional context parameter to be used as `this` when calling the iterator function.","optional":true}},"returns":{"type":"Array","description":"An array in the form of [trueCollection, falseCollection]"},"see":""},"select":{"summary":"<p>Return the group of elements for which the return value of the iterator is true.</p>","code_sample":"","source":"Array.prototype.select = function(iterator, context) {\n  return this.partition(iterator, context)[0];\n};","parameters":{"iterator":{"type":"Function","description":"The iterator receives each element in turn as the first agument.","optional":false},"context":{"type":"Object","description":"Optional context parameter to be used as `this` when calling the iterator function.","optional":true}},"returns":{"type":"Array","description":"An array containing the elements for which the iterator returned true."},"see":""},"without":{"summary":"<p>Return the group of elements that are not in the passed in set.</p>","code_sample":"<pre><code>[1, 2, 3, 4].without ([2, 3])\n# =&gt; [1, 4]\n</code></pre>","source":"Array.prototype.without = function(values) {\n  return this.reject(function(element) {\n    return values.include(element);\n  });\n};","parameters":{"values":{"type":"Array","description":"List of elements to exclude.","optional":false}},"returns":{"type":"Array","description":"An array containing the elements that are not passed in."},"see":""},"reject":{"summary":"<p>Return the group of elements for which the return value of the iterator is false.</p>","code_sample":"","source":"Array.prototype.reject = function(iterator, context) {\n  return this.partition(iterator, context)[1];\n};","parameters":{"iterator":{"type":"Function","description":"The iterator receives each element in turn as the first agument.","optional":false},"context":{"type":"Object","description":"Optional context parameter to be used as `this` when calling the iterator function.","optional":true}},"returns":{"type":"Array","description":"An array containing the elements for which the iterator returned false."},"see":""},"inject":{"summary":"<p>Combines all elements of the array by applying a binary operation.<br />for each element in the arra the iterator is passed an accumulator<br />value (memo) and the element.</p>","code_sample":"","source":"Array.prototype.inject = function(initial, iterator) {\n  this.each(function(element) {\n    return initial = iterator(initial, element);\n  });\n  return initial;\n};","parameters":{},"returns":{"type":"Object","description":"The result of a"},"see":""},"sum":{"summary":"<p>Add all the elements in the array.</p>","code_sample":"<pre><code>[1, 2, 3, 4].sum()\n# =&gt; 10\n</code></pre>","source":"Array.prototype.sum = function() {\n  return this.inject(0, function(sum, n) {\n    return sum + n;\n  });\n};","parameters":{},"returns":{"type":"Number","description":"The sum of the elements in the array."},"see":""},"product":{"summary":"<p>Multiply all the elements in the array.</p>","code_sample":"<pre><code>[1, 2, 3, 4].product()\n# =&gt; 24\n</code></pre>","source":"Array.prototype.product = function() {\n  return this.inject(1, function(product, n) {\n    return product * n;\n  });\n};","parameters":{},"returns":{"type":"Number","description":"The product of the elements in the array."},"see":""},"zip":{"summary":"<p>Merges together the values of each of the arrays with the values at the corresponding position.</p>","code_sample":"<pre><code>['a', 'b', 'c'].zip([1, 2, 3])\n# =&gt; [['a', 1], ['b', 2], ['c', 3]]\n</code></pre>","source":"Array.prototype.zip = function() {\n  var args;\n  args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];\n  return this.map(function(element, index) {\n    var output;\n    output = args.map(function(arr) {\n      return arr[index];\n    });\n    output.unshift(element);\n    return output;\n  });\n};\n;","parameters":{},"returns":{"type":"Array","description":"Array groupings whose values are arranged by their positions in the original input arrays."},"see":""},"pop":{"summary":"<p>Removes the last element from an array and returns that element.</p>","code_sample":"<p><code><br /><i>array</i>.pop()<br /></code></p>","source":null,"parameters":{},"returns":{},"see":""},"push":{"summary":"<p>Mutates an array by appending the given elements and returning the new length of<br />the array.</p>","code_sample":"<p><code><em>array</em>.push(<em>element1</em>, ..., <em>elementN</em>)</code></p>","source":null,"parameters":{"...,":{"type":"element1, ","description":"elementN The elements to add to the end of the array.","optional":false}},"returns":{},"see":""},"reverse":{"summary":"<p>Reverses an array in place.  The first array element becomes the last and the<br />last becomes the first.</p>","code_sample":"<p><code>array.reverse()</code></p>","source":null,"parameters":{},"returns":{},"see":""},"shift":{"summary":"<p>Removes the first element from an array and returns that element. This method<br />changes the length of the array.</p>","code_sample":"<p><code><em>array</em>.shift()</code></p>","source":null,"parameters":{},"returns":{},"see":""},"sort":{"summary":"<p>Sorts the elements of an array in place.</p>","code_sample":"<p><code><em>array</em>.sort([<em>compareFunction</em>])</code></p>","source":null,"parameters":{"Specifies":{"type":"compareFunction","description":"a function that defines the sort order. If","optional":false}},"returns":{},"see":""},"splice":{"summary":"<p>Changes the content of an array, adding new elements while removing old<br />elements.</p>","code_sample":"<p><code><em>array</em>.splice(<em>index</em>, <em>howMany</em>[, <em>element1</em>[, ...[, <em>elementN</em>]]])</code></p>","source":null,"parameters":{"Index":{"type":"index","description":"at which to start changing the array. If negative, will","optional":false},"An":{"type":"howMany","description":"integer indicating the number of old array elements to","optional":false},"...,":{"type":"element1, ","description":"elementN The elements to add to the array. If you don't","optional":false}},"returns":{},"see":""},"unshift":{"summary":"<p>Adds one or more elements to the beginning of an array and returns the new<br />length of the array.</p>","code_sample":"<p><code><em>arrayName</em>.unshift(<em>element1</em>, ..., <em>elementN</em>) </code></p>","source":null,"parameters":{"...,":{"type":"element1, ","description":"elementN The elements to add to the front of the array.","optional":false}},"returns":{},"see":""},"concat":{"summary":"<p>Returns a new array comprised of this array joined with other array(s) and/or<br />value(s).</p>","code_sample":"<p><code><em>array</em>.concat(<em>value1</em>, <em>value2</em>, ..., <em>valueN</em>)</code></p>","source":null,"parameters":{"Arrays":{"type":"valueN","description":"and/or values to concatenate to the resulting array.","optional":false}},"returns":{},"see":""},"join":{"summary":"<p>Joins all elements of an array into a string.</p>","code_sample":"<p><code><em>array</em>.join(<em>separator</em>)</code></p>","source":null,"parameters":{"Specifies":{"type":"separator","description":"a string to separate each element of the array. The","optional":false}},"returns":{},"see":""},"slice":{"summary":"<p>Returns a one-level deep copy of a portion of an array.</p>","code_sample":"<p><code><em>array</em>.slice(<em>begin</em>[, <em>end</em>])</code></p>","source":null,"parameters":{"Zero-based":{"type":"end","description":"index at which to end extraction. slice extracts up to","optional":false}},"returns":{},"see":""},"toString":{"summary":"<p>Returns a string representing the specified array and its elements.</p>","code_sample":"<p><code><em>array</em>.toString()</code></p>","source":null,"parameters":{},"returns":{},"see":""},"indexOf":{"summary":"<p>Returns the first index at which a given element can be found in the array, or<br />-1 if it is not present.</p>","code_sample":"<p><code><em>array</em>.indexOf(<em>searchElement</em>[, <em>fromIndex</em>])</code></p>","source":null,"parameters":{"fromIndex":{"type":"searchElement","description":"Element to locate in the array.The index at","optional":false}},"returns":{},"see":""},"lastIndexOf":{"summary":"<p>Returns the last index at which a given element can be found in the array, or -1<br />if it is not present. The array is searched backwards, starting at fromIndex.</p>","code_sample":"<p><code><em>array</em>.lastIndexOf(<em>searchElement</em>[, <em>fromIndex</em>])</code></p>","source":null,"parameters":{"fromIndex":{"type":"searchElement","description":"Element to locate in the array.The index at","optional":false}},"returns":{},"see":""},"filter":{"summary":"<p>Creates a new array with all elements that pass the test implemented by the<br />provided function.</p>","code_sample":"<p><code><em>array</em>.filter(<em>callback</em>[, <em>thisObject</em>])</code></p>","source":null,"parameters":{"thisObject":{"type":"callback","description":"Function to test each element of the array.Object to","optional":false}},"returns":{},"see":""},"forEach":{"summary":"<p>Executes a provided function once per array element.</p>","code_sample":"<p><code><em>array</em>.forEach(<em>callback</em>[, <em>thisObject</em>])</code></p>","source":null,"parameters":{"thisObject":{"type":"callback","description":"Function to execute for each element.Object to use","optional":false}},"returns":{},"see":""},"every":{"summary":"<p>Tests whether all elements in the array pass the test implemented by the<br />provided function.</p>","code_sample":"<p><code><em>array</em>.every(<em>callback</em>[, <em>thisObject</em>])</code></p>","source":null,"parameters":{"Function":{"type":"callbackthisObject","description":"to test for each element.Object to use as","optional":false}},"returns":{},"see":""},"some":{"summary":"<p>Tests whether some element in the array passes the test implemented by the<br />provided function.</p>","code_sample":"<p><code><em>array</em>.some(<em>callback</em>[, <em>thisObject</em>])</code></p>","source":null,"parameters":{"thisObject":{"type":"callback","description":"Function to test for each element.Object to use as","optional":false}},"returns":{},"see":""},"reduce":{"summary":"<p>Apply a function against an accumulator and each value of the array (from<br />left-to-right) as to reduce it to a single value.</p>","code_sample":"<p><code><em>array</em>.reduce(<em>callback</em>[, <em>initialValue</em>])</code></p>","source":null,"parameters":{"Function":{"type":"callbackinitialValue","description":"to execute on each value in the","optional":false}},"returns":{},"see":""},"reduceRight":{"summary":"<p>Apply a function simultaneously against two values of the array (from<br />right-to-left) as to reduce it to a single value.</p>","code_sample":"<p><code><em>array</em>.reduceRight(<em>callback</em>[, <em>initialValue</em>])</code></p>","source":null,"parameters":{"initialValue":{"type":"callback","description":"Function to execute on each value in the","optional":false}},"returns":{},"see":""}}}},{"Bindable#":{"method_list":["bind","unbind","trigger"],"methods":{"bind":{"summary":"<p>Adds a function as an event listener.</p>","code_sample":"<pre><code># this will call coolEventHandler after\n# yourObject.trigger \"someCustomEvent\" is called.\nyourObject.bind \"someCustomEvent\", coolEventHandler\n\n#or\nyourObject.bind \"anotherCustomEvent\", -&gt;\n  doSomething()\n</code></pre>","source":"bind: function(event, callback) {\n      eventCallbacks[event] = eventCallbacks[event] || [];\n      return eventCallbacks[event].push(callback);\n    },","parameters":{"event":{"type":"String","description":"The event to listen to.","optional":false},"callback":{"type":"Function","description":"The function to be called when the specified event is triggered.","optional":false}},"returns":{},"see":""},"unbind":{"summary":"<p>Removes a specific event listener, or all event listeners if<br />no specific listener is given.</p>","code_sample":"<p>Another paragraph.</p>\n\n<pre><code>#  removes the handler coolEventHandler from the event\n# \"someCustomEvent\" while leaving the other events intact.\nyourObject.unbind \"someCustomEvent\", coolEventHandler\n\n# removes all handlers attached to \"anotherCustomEvent\"\nyourObject.unbind \"anotherCustomEvent\"\n</code></pre>","source":"unbind: function(event, callback) {\n      eventCallbacks[event] = eventCallbacks[event] || [];\n      if (callback) {\n        return eventCallbacks[event].remove(callback);\n      } else {\n        return eventCallbacks[event] = [];\n      }\n    },","parameters":{"event":{"type":"String","description":"The event to remove the listener from.","optional":false},"callback":{"type":"Function","description":"The listener to remove.","optional":true}},"returns":{},"see":""},"trigger":{"summary":"<p>Calls all listeners attached to the specified event.</p>","code_sample":"<pre><code># calls each event handler bound to \"someCustomEvent\"\nyourObject.trigger \"someCustomEvent\"\n</code></pre>","source":"trigger: function() {\n      var callbacks, event, parameters, self;\n      event = arguments[0], parameters = 2 <= arguments.length ? __slice.call(arguments, 1) : [];\n      callbacks = eventCallbacks[event];\n      if (callbacks && callbacks.length) {\n        self = this;\n        return callbacks.each(function(callback) {\n          return callback.apply(self, parameters);\n        });\n      }\n    }\n  };\n};\n\n(typeof exports !== \"undefined\" && exports !== null ? exports : this)[\"Bindable\"] = Bindable;\n;\nvar CommandStack;\n\nCommandStack = function() {\n  var index, stack;\n  stack = [];\n  index = 0;\n  return {\n    execute: function(command) {\n      stack[index] = command;\n      command.execute();\n      return stack.length = index += 1;\n    },\n    undo: function() {\n      var command;\n      if (this.canUndo()) {\n        index -= 1;\n        command = stack[index];\n        command.undo();\n        return command;\n      }\n    },\n    redo: function() {\n      var command;\n      if (this.canRedo()) {\n        command = stack[index];\n        command.execute();\n        index += 1;\n        return command;\n      }\n    },\n    canUndo: function() {\n      return index > 0;\n    },\n    canRedo: function() {\n      return stack[index] != null;\n    }\n  };\n};\n;","parameters":{"event":{"type":"String","description":"The event to trigger.","optional":false},"parameters":{"type":"Array","description":"Additional parameters to pass to the event listener.","optional":true}},"returns":{},"see":""}}}},{"Bindable.":{"method_list":[],"methods":{}}},{"Boolean#":{"method_list":["toString","valueOf"],"methods":{"toString":{"summary":"<p>Returns a string representing the specified Boolean object.</p>","code_sample":"<p><code>bool.toString()</code></p>","source":null,"parameters":{},"returns":{},"see":""},"valueOf":{"summary":"<p>Returns the primitive value of a Boolean object.</p>","code_sample":"<p><code>bool.valueOf()</code></p>","source":null,"parameters":{},"returns":{},"see":""}}}},{"Bounded#":{"method_list":["distance","position","collides","collisionBounds","bounds","centeredBounds","center","circle"],"methods":{"distance":{"summary":"<p>Distance between two objects. Proxies to Point.distance.<br />In order for this to work, <code>otherObj</code> must have a<br />position method.</p>","code_sample":"<pre><code>player = GameObject\n  x: 50\n  y: 50\n  width: 10\n  height: 10\n\nplayer.include Bounded\n\nenemy = GameObject\n  x: 110\n  y: 120\n  width: 7\n  height: 20\n\nplayer.distance(enemy)\n# =&gt; 92.19544457292888\n</code></pre>","source":"distance: function(otherObj) {\n      return Point.distance(self.position(), otherObj.position());\n    },","parameters":{},"returns":{"type":"Number","description":"Distance between the two objects"},"see":"Point.distance"},"position":{"summary":"<p>The position of this game object. By default it is the top left point.<br />Redefining the center method will change the relative position.</p>","code_sample":"<pre><code>player = Core\n  x: 50\n  y: 40\n\nplayer.include(Bounded)\n\nplayer.position()\n# =&gt; {x: 50, y: 40}\n</code></pre>","source":"position: function(newPosition) {\n      if (newPosition != null) {\n        I.x = newPosition.x;\n        return I.y = newPosition.y;\n      } else {\n        return Point(I.x, I.y);\n      }\n    },\n    changePosition: function(delta) {\n      I.x += delta.x;\n      I.y += delta.y;\n      return self;\n    },","parameters":{},"returns":{"type":"Point","description":"The position of this object"},"see":""},"collides":{"summary":"<p>Does a check to see if this object is overlapping<br />with the bounds passed in.</p>","code_sample":"<pre><code>player = Core\n  x: 4\n  y: 6\n  width: 20\n  height: 20\n\nplayer.include(Bounded)\n\nplayer.collides({x: 5, y: 7, width: 20, height: 20})\n# =&gt; true\n</code></pre>","source":"collides: function(bounds) {\n      return Collision.rectangular(self.bounds(), bounds);\n    },","parameters":{},"returns":{"type":"Point","description":"The position of this object"},"see":""},"collisionBounds":{"summary":"<p>This returns a modified bounds based on the collision margin.<br />The area of the bounds is reduced if collision margin is positive<br />and increased if collision margin is negative.</p>","code_sample":"<pre><code>player = Core\n  collisionMargin:\n    x: -2\n    y: -4\n  x: 50\n  y: 50\n  width: 20\n  height: 20\n\nplayer.include(Bounded)\n\nplayer.collisionBounds()\n# =&gt; {x: 38, y: 36, height: 28, width: 24}\n\nplayer.collisionBounds(10, 10)\n# =&gt; {x: 48, y: 46, height: 28, width: 24}\n</code></pre>","source":"collisionBounds: function(xOffset, yOffset) {\n      var bounds;\n      bounds = self.bounds(xOffset, yOffset);\n      bounds.x += I.collisionMargin.x;\n      bounds.y += I.collisionMargin.y;\n      bounds.width -= 2 * I.collisionMargin.x;\n      bounds.height -= 2 * I.collisionMargin.y;\n      return bounds;\n    },","parameters":{"xOffset":{"type":"Number","description":"the amount to shift the x position","optional":false},"yOffset":{"type":"Number","description":"the amount to shift the y position","optional":false}},"returns":{"type":"Object","description":"The collision bounds"},"see":""},"bounds":{"summary":"<p>Returns infomation about the location of the object and its dimensions with optional offsets.</p>","code_sample":"<pre><code>player = Core\n  x: 3\n  y: 6\n  width: 2\n  height: 2\n\nplayer.include(Bounded)\n\nplayer.bounds()\n# =&gt; {x: 3, y: 6, width: 2, height: 2}\n\nplayer.bounds(7, 4)\n# =&gt; {x: 10, y: 10, width: 2, height: 2}\n</code></pre>","source":"bounds: function(xOffset, yOffset) {\n      var center;\n      center = self.center();\n      return {\n        x: center.x - I.width / 2 + (xOffset || 0),\n        y: center.y - I.height / 2 + (yOffset || 0),\n        width: I.width,\n        height: I.height\n      };\n    },","parameters":{"xOffset":{"type":"Number","description":"the amount to shift the x position","optional":false},"yOffset":{"type":"Number","description":"the amount to shift the y position","optional":false}},"returns":{},"see":""},"centeredBounds":{"summary":"<p>The centeredBounds method returns infomation about the center<br />of the object along with the midpoint of the width and height.</p>","code_sample":"<pre><code>player = Core\n  x: 3\n  y: 6\n  width: 2\n  height: 2\n\nplayer.include(Bounded)\n\nplayer.centeredBounds()\n# =&gt; {x: 4, y: 7, xw: 1, yw: 1}\n</code></pre>","source":"centeredBounds: function() {\n      var center;\n      center = self.center();\n      return {\n        x: center.x,\n        y: center.y,\n        xw: I.width / 2,\n        yw: I.height / 2\n      };\n    },","parameters":{},"returns":{},"see":""},"center":{"summary":"<p>The center method returns the {@link Point} that is<br />the center of the object.</p>","code_sample":"<pre><code>player = Core\n  x: 50\n  y: 40\n  width: 10\n  height: 30\n\nplayer.include(Bounded)\n\nplayer.center()\n# =&gt; {x: 30, y: 35}\n</code></pre>","source":"center: function(newCenter) {\n      return self.position(newCenter);\n    },","parameters":{},"returns":{"type":"Point","description":"The middle of the calling object"},"see":""},"circle":{"summary":"<p>Return the circular bounds of the object. The circle is<br />centered at the midpoint of the object.</p>","code_sample":"<pre><code>player = Core\n  radius: 5\n  x: 50\n  y: 50\n  other: \"stuff\"\n\nplayer.include(Bounded)\n\nplayer.circle()\n# =&gt; {radius: 5, x: 50, y: 50}\n</code></pre>","source":"circle: function() {\n      var circle;\n      circle = self.center();\n      circle.radius = I.radius || I.width / 2 || I.height / 2;\n      return circle;\n    }\n  };\n};\n;\nvar Camera;\n\nCamera = function(I) {\n  var currentObject, currentType, focusOn, followTypes, objectFilters, self, transformFilters;\n  if (I == null) I = {};\n  Object.reverseMerge(I, {\n    cameraBounds: Rectangle({\n      x: 0,\n      y: 0,\n      width: App.width,\n      height: App.height\n    }),\n    screen: Rectangle({\n      x: 0,\n      y: 0,\n      width: App.width,\n      height: App.height\n    }),\n    deadzone: Point(0, 0),\n    zoom: 1,\n    transform: Matrix(),\n    x: App.width / 2,\n    y: App.height / 2,\n    velocity: Point.ZERO,\n    maxSpeed: 25,\n    t90: 2\n  });\n  currentType = \"centered\";\n  currentObject = null;\n  objectFilters = [];\n  transformFilters = [];\n  focusOn = function(object) {\n    var c, dampingFactor, delta, dt, force, objectCenter, objectVelocity, target;\n    dt = 1 / 30;\n    dampingFactor = 2;\n    c = dt * 3.75 / I.t90;\n    if (c >= 1) {\n      self.position(target);\n      return I.velocity = Point.ZERO;\n    } else {\n      objectCenter = object.center();\n      objectVelocity = object.I.velocity;\n      if (objectVelocity) {\n        target = objectCenter.add(objectVelocity.scale(5));\n      } else {\n        target = objectCenter;\n      }\n      delta = target.subtract(self.position());\n      force = delta.subtract(I.velocity.scale(dampingFactor));\n      self.changePosition(I.velocity.scale(c).clamp(I.maxSpeed));\n      return I.velocity = I.velocity.add(force.scale(c));\n    }\n  };\n  followTypes = {\n    centered: function(object) {\n      I.deadzone = Point(0, 0);\n      return focusOn(object);\n    },\n    topdown: function(object) {\n      var helper;\n      helper = Math.max(I.screen.width, I.screen.height) / 4;\n      I.deadzone = Point(helper, helper);\n      return focusOn(object);\n    },\n    platformer: function(object) {\n      var height, width;\n      width = I.screen.width / 8;\n      height = I.screen.height / 3;\n      I.deadzone = Point(width, height);\n      return focusOn(object);\n    }\n  };\n  self = Core(I).extend({\n    follow: function(object, type) {\n      if (type == null) type = \"centered\";\n      currentObject = object;\n      return currentType = type;\n    },\n    objectFilterChain: function(fn) {\n      return objectFilters.push(fn);\n    },\n    transformFilterChain: function(fn) {\n      return transformFilters.push(fn);\n    }\n  });\n  self.include(Bindable);\n  self.attrAccessor(\"transform\");\n  self.bind(\"afterUpdate\", function() {\n    if (currentObject) followTypes[currentType](currentObject);\n    I.x = I.x.clamp(I.cameraBounds.left + I.screen.width / 2, I.cameraBounds.right - I.screen.width / 2);\n    I.y = I.y.clamp(I.cameraBounds.top + I.screen.height / 2, I.cameraBounds.bottom - I.screen.height / 2);\n    return I.transform = Matrix.translate(-I.x, -I.y);\n  });\n  self.bind(\"draw\", function(canvas, objects) {\n    return canvas.withTransform(Matrix.translate(I.screen.x, I.screen.y), function(canvas) {\n      var transform;\n      canvas.clip(0, 0, I.screen.width, I.screen.height);\n      objects = objectFilters.pipeline(objects);\n      transform = transformFilters.pipeline(self.transform().copy());\n      canvas.withTransform(Matrix.translation(I.screen.width / 2, I.screen.height / 2), function(canvas) {\n        return canvas.withTransform(transform, function(canvas) {\n          self.trigger(\"beforeDraw\", canvas);\n          return objects.invoke(\"draw\", canvas);\n        });\n      });\n      return self.trigger('flash', canvas);\n    });\n  });\n  self.bind(\"overlay\", function(canvas, objects) {\n    return canvas.withTransform(Matrix.translate(I.screen.x, I.screen.y), function(canvas) {\n      canvas.clip(0, 0, I.screen.width, I.screen.height);\n      objects = objectFilters.pipeline(objects);\n      return objects.invoke(\"trigger\", \"overlay\", canvas);\n    });\n  });\n  self.include(Bounded);\n  self.include(Camera.ZSort);\n  self.include(Camera.Zoom);\n  self.include(Camera.Rotate);\n  self.include(Camera.Shake);\n  self.include(Camera.Flash);\n  self.include(Camera.Fade);\n  return self;\n};\n;","parameters":{},"returns":{"type":"Object","description":"An object with a position and a radius"},"see":""}}}},{"Bounded.":{"method_list":[],"methods":{}}},{"Camera#":{"method_list":["fadeIn","fadeOut","flash"],"methods":{"fadeIn":{"summary":"<p>A convenient way to set the flash effect instance variables. This provides a shorthand for fading the screen in<br />from a given color over a specified duration.</p>","code_sample":"<pre><code>engine.fadeIn()\n# =&gt; Sets the effect variables to their default state. This will the screen to go from black to transparent over the next 30 frames.\n\nengine.fadeIn('blue', 50)\n# =&gt; This effect will start off blue and fade to transparent over 50 frames.\n</code></pre>","source":"fadeIn: function(options) {\n      var alpha, color, duration, _ref;\n      if (options == null) options = {};\n      _ref = Object.reverseMerge(options, fadeInDefaults), alpha = _ref.alpha, color = _ref.color, duration = _ref.duration;\n      return configureFade(duration, color, alpha);\n    },","parameters":{"duration=30":{"type":"Number","description":"How long the effect lasts","optional":true},"color=\"black\"":{"type":"Color","description":"The color to fade from","optional":true}},"returns":{},"see":""},"fadeOut":{"summary":"<p>A convenient way to set the flash effect instance variables. This provides a shorthand for fading<br />the screen to a given color over a specified duration.</p>","code_sample":"<pre><code>camera.fadeOut()\n# =&gt; Sets the effect variables to their default state. This will the screen to fade from ransparent to black over the next 30 frames.\n\ncamera.fadeOut('blue', 50)\n# =&gt; This effect will start off transparent and change to blue over 50 frames.\n</code></pre>","source":"fadeOut: function(options) {\n      var alpha, color, duration, _ref;\n      if (options == null) options = {};\n      _ref = Object.reverseMerge(options, fadeOutDefaults), alpha = _ref.alpha, color = _ref.color, duration = _ref.duration;\n      return configureFade(duration, color, alpha);\n    }\n  };\n};\n;","parameters":{"duration=30":{"type":"Number","description":"How long the effect lasts","optional":true},"color=\"transparent\"":{"type":"Color","description":"The color to fade to","optional":true}},"returns":{},"see":""},"flash":{"summary":"<p>A convenient way to set the flash effect instance variables. Alternatively, you can modify them by hand, but<br />using Camera#flash is the suggested approach.</p>","code_sample":"<pre><code>camera.flash()\n# =&gt; Sets the flash effect variables to their default state. This will cause a white flash that will turn transparent in the next 12 frames.\n\ncamera.flash\n  color: 'green'\n  duration: 30\n# =&gt; This flash effect will start off green and fade to transparent over 30 frames.\n\ncamera.flash\n  color: Color(255, 0, 0, 0)\n  duration: 20\n  targetAlpha: 1\n# =&gt; This flash effect will start off transparent and move toward red over 20 frames\n</code></pre>","source":"flash: function(options) {\n      var color, duration, targetAlpha;\n      if (options == null) options = {};\n      Object.reverseMerge(options, defaultParams);\n      color = options.color, duration = options.duration, targetAlpha = options.targetAlpha;\n      I.flashColor = Color(color);\n      I.flashTargetAlpha = targetAlpha;\n      I.flashCooldown = duration;\n      I.flashDuration = duration;\n      return self;\n    }\n  };\n};\n;\n\nCamera.Rotate = function(I, self) {\n  Object.reverseMerge(I, {\n    rotation: 0\n  });\n  self.transformFilterChain(function(transform) {\n    return transform.rotate(I.rotation, self.position());\n  });\n  self.attrAccessor(\"rotation\");\n  return {\n    rotate: function(amount) {\n      return self.rotation(I.rotation + amount);\n    }\n  };\n};\n;\n\nCamera.Shake = function(I, self) {\n  var defaultParams;\n  Object.reverseMerge(I, {\n    shakeIntensity: 20,\n    shakeCooldown: 0\n  });\n  defaultParams = {\n    duration: 10,\n    intensity: 20\n  };\n  self.bind(\"afterUpdate\", function() {\n    return I.shakeCooldown = I.shakeCooldown.approach(0, 1);\n  });\n  self.transformFilterChain(function(transform) {\n    if (I.shakeCooldown > 0) {\n      transform.tx += signedRand(I.shakeIntensity);\n      transform.ty += signedRand(I.shakeIntensity);\n    }\n    return transform;\n  });\n  return {\n    shake: function(options) {\n      var duration, intensity, _ref;\n      if (options == null) options = {};\n      _ref = Object.reverseMerge(options, defaultParams), duration = _ref.duration, intensity = _ref.intensity;\n      I.shakeCooldown = duration * I.zoom;\n      I.shakeIntensity = intensity * I.zoom;\n      return self;\n    }\n  };\n};\n;\n\nCamera.Zoom = function(I, self) {\n  var clampZoom;\n  Object.reverseMerge(I, {\n    maxZoom: 10,\n    minZoom: 0.1,\n    zoom: 1\n  });\n  self.transformFilterChain(function(transform) {\n    return transform.scale(I.zoom, I.zoom, self.position());\n  });\n  clampZoom = function(value) {\n    return value.clamp(I.minZoom, I.maxZoom);\n  };\n  return {\n    zoomIn: function(percentage) {\n      return self.zoom(clampZoom(I.zoom * (1 + percentage)));\n    },\n    zoomOut: function(percentage) {\n      return self.zoom(clampZoom(I.zoom * (1 - percentage)));\n    },\n    zoom: function(value) {\n      if (value != null) {\n        I.zoom = clampZoom(value);\n        return self;\n      } else {\n        return I.zoom;\n      }\n    }\n  };\n};\n;\n\nCamera.ZSort = function(I, self) {\n  Object.reverseMerge(I, {\n    zSort: true\n  });\n  self.objectFilterChain(function(objects) {\n    if (I.zSort) {\n      objects.sort(function(a, b) {\n        return a.I.zIndex - b.I.zIndex;\n      });\n    }\n    return objects;\n  });\n  return {};\n};\n;","parameters":{"color=\"white\"":{"type":"Color","description":"The flash color","optional":true},"duration=12":{"type":"Number","description":"How long the effect lasts","optional":true},"targetAlpha=0":{"type":"Number","description":"The alpha value to fade to. By default, this is set to 0, which fades the color to transparent.","optional":true}},"returns":{},"see":""}}}},{"Clampable#":{"method_list":["clamp","clampToBounds"],"methods":{"clamp":{"summary":"<p>Keep an objects attributes within a given range.</p>","code_sample":"<pre><code># Player's health will be within [0, 100] at the end of every update\nplayer.clamp\n  health:\n    min: 0\n    max: 100\n\n# Score can only be positive\nplayer.clamp\n  score:\n    min: 0\n</code></pre>","source":"clamp: function(data) {\n      return Object.extend(I.clampData, data);\n    },","parameters":{"data":{"type":"Object","description":"","optional":false}},"returns":{},"see":""},"clampToBounds":{"summary":"<p>Helper to clamp the <code>x</code> and <code>y</code> properties of the object to be within a given bounds.</p>","code_sample":"","source":"clampToBounds: function(bounds) {\n      bounds || (bounds = Rectangle({\n        x: 0,\n        y: 0,\n        width: App.width,\n        height: App.height\n      }));\n      return self.clamp({\n        x: {\n          min: bounds.x + I.width / 2,\n          max: bounds.width - I.width / 2\n        },\n        y: {\n          min: bounds.y + I.height / 2,\n          max: bounds.height - I.height / 2\n        }\n      });\n    }\n  };\n};\n;\n\n(function() {","parameters":{"bounds":{"type":"Rectangle","description":"The bounds to clamp the object's position within. Defaults to the app size if none given.","optional":true}},"returns":{},"see":""}}}},{"Clampable.":{"method_list":[],"methods":{}}},{"Collidable.":{"method_list":[],"methods":{}}},{"Collision.":{"method_list":[],"methods":{}}},{"Color#":{"method_list":["channels","complement","complement$","copy","darken","darken$","desaturate","desaturate$","equal","grayscale","grayscale$","hue","lightness","shiftHue","shiftHue$","lighten","lighten$","mixWith","mixWith$","saturate","saturate$","saturation","toHex","toHsl","toString","transparentize","transparentize$","opacify","opacify$"],"methods":{"channels":{"summary":"<p>Returns the rgba color channels in an array.</p>","code_sample":"<pre><code>transparent =  Color()\n\ntransparent.channels()\n# =&gt; [0, 0, 0, 0]\n\nred = Color(\"#FF0000\")\n\nred.channels()\n# =&gt; [255, 0, 0, 1]\n\nrgb = Color(200, 34, 2)\n\nrgb.channels()\n# =&gt; [200, 34, 2, 1]\n</code></pre>","source":"channels: function() {\n      return [this.r, this.g, this.b, this.a];\n    },","parameters":{},"returns":{"type":"Array","description":"Array of r, g, b, and alpha values of the color"},"see":""},"complement":{"summary":"<p>A copy of the calling color that is its complementary color on the color wheel.</p>","code_sample":"<p><code class=\"run\"><pre><br />red = Color(255, 0, 0)</p>\n\n<p>cyan = red.complement()</p>\n\n<h1>to see what they look like</h1>\n\n<p>for color, index in [red, cyan]<br />  canvas.drawRect<br />    color: color<br />    x: 20 + (60 * index)<br />    y: 20 + (60 * index)<br />    width: 60<br />    height: 60<br /></pre></code></p>","source":"complement: function() {\n      return this.copy().complement$();\n    },","parameters":{},"returns":{"type":"Color","description":"new color that is a copy of the calling color with its hue shifted by 180 degrees on the color wheel"},"see":""},"complement$":{"summary":"<p>Modifies the calling color to make it the complement of its previous value.</p>","code_sample":"<pre><code>red = Color(255, 0, 0)\n\n# modifies red in place to make it into cyan\nred.complement$()\n\nred.toString()\n# =&gt; 'rgba(0, 255, 255, 1)'\n</code></pre>","source":"complement$: function() {\n      return this.shiftHue$(180);\n    },","parameters":{},"returns":{"type":"Color","description":"the color hue shifted by 180 degrees on the color wheel. Modifies the existing color."},"see":""},"copy":{"summary":"<p>A copy of the calling color.</p>","code_sample":"<pre><code>color = Color(0, 100, 200)\n\ncopy = color.copy()\n\ncolor == copy\n# =&gt; false\n\ncolor.equal(copy)\n# =&gt; true\n</code></pre>","source":"copy: function() {\n      return Color(this.r, this.g, this.b, this.a);\n    },","parameters":{},"returns":{"type":"Color","description":"A new color. A copy of the calling color"},"see":""},"darken":{"summary":"<p>Returns a copy of the calling color darkened by <code>amount</code> (Lightness of the color ranges from 0 to 1).</p>","code_sample":"<p><code class=\"run\"><pre><br />green = Color(0, 255, 0)</p>\n\n<p>darkGreen = green.darken(0.3)</p>\n\n<h1>to see what they look like</h1>\n\n<p>for color, index in [green, darkGreen]<br />  canvas.drawRect<br />    color: color<br />    x: 20 + (60 * index)<br />    y: 20 + (60 * index)<br />    width: 60<br />    height: 60<br /></pre></code></p>","source":"darken: function(amount) {\n      return this.copy().darken$(amount);\n    },","parameters":{"amount":{"type":"Number","description":"Amount to darken color by (between 0 - 1)","optional":false}},"returns":{"type":"Color","description":"A new color. The lightness value is reduced by `amount` from the original."},"see":""},"darken$":{"summary":"<p>Modifies the color so that it is darkened by <code>amount</code> (Lightness of the color ranges from 0 to 1).</p>","code_sample":"<pre><code>green = Color(0, 255, 0)\n\n# Modifies green to be darkGreen\ngreen.darken$(0.3)\n\ngreen.toString()\n# =&gt; 'rgba(0, 102, 0, 1)'\n</code></pre>","source":"darken$: function(amount) {\n      var hsl, _ref;\n      hsl = this.toHsl();\n      hsl[2] -= amount;\n      _ref = hslToRgb(hsl), this.r = _ref[0], this.g = _ref[1], this.b = _ref[2], this.a = _ref[3];\n      return this;\n    },","parameters":{"amount":{"type":"Number","description":"Amount to darken color by (between 0 - 1)","optional":false}},"returns":{"type":"Color","description":"the color with the lightness value reduced by `amount`"},"see":""},"desaturate":{"summary":"<p>A copy of the calling color with its saturation reduced by <code>amount</code>.</p>","code_sample":"<p><code class=\"run\"><pre><br />blue = Color(0, 0, 255)</p>\n\n<p>desaturatedBlue = blue.desaturate(0.4)</p>\n\n<h1>to see what they look like</h1>\n\n<p>for color, index in [blue, desaturatedBlue]<br />  canvas.drawRect<br />    color: color<br />    x: 20 + (60 * index)<br />    y: 20 + (60 * index)<br />    width: 60<br />    height: 60<br /></pre></code></p>","source":"desaturate: function(amount) {\n      return this.copy().desaturate$(amount);\n    },","parameters":{"amount":{"type":"Number","description":"Amount to reduce color saturation by (between 0 and 1)","optional":false}},"returns":{"type":"Color","description":"A copy of the color with the saturation value reduced by `amount`"},"see":""},"desaturate$":{"summary":"<p>The modified color with its saturation reduced by <code>amount</code>.</p>","code_sample":"<pre><code>blue = Color(0, 0, 255)\n\n# modifies blue to be desaturatedBlue\nblue.desaturate$(0.4)\n\nblue.toString()\n# =&gt; 'rgba(38, 38, 217, 1)'\n</code></pre>","source":"desaturate$: function(amount) {\n      var hsl, _ref;\n      hsl = this.toHsl();\n      hsl[1] -= amount;\n      _ref = hslToRgb(hsl), this.r = _ref[0], this.g = _ref[1], this.b = _ref[2], this.a = _ref[3];\n      return this;\n    },","parameters":{"amount":{"type":"Number","description":"Amount to reduce color saturation by (between 0 and 1)","optional":false}},"returns":{"type":"Color","description":"the color with the saturation value reduced by `amount`"},"see":""},"equal":{"summary":"<p>Determine whether two colors are equal. Compares their r, g, b, and alpha values.</p>","code_sample":"<pre><code>hex = Color('#ffff00')\nrgb = Color(255, 255, 0)\n\nhex == rgb\n# =&gt; false\n\nhex.equal(rgb)\n# =&gt; true\n</code></pre>","source":"equal: function(other) {\n      return other.r === this.r && other.g === this.g && other.b === this.b && other.a === this.a;\n    },","parameters":{"other":{"type":"Color","description":"the color to compare to the calling color","optional":false}},"returns":{"type":"Boolean","description":"true if the r, g, b, a values of the colors agree, false otherwise"},"see":""},"grayscale":{"summary":"<p>A copy of the calling color converted to grayscale.</p>","code_sample":"<p><code class=\"run\"><pre><br />yellow = Color(255, 255, 0)</p>\n\n<p>gray = yellow.grayscale()</p>\n\n<h1>to see what they look like</h1>\n\n<p>for color, index in [yellow, gray]<br />  canvas.drawRect<br />    color: color<br />    x: 20 + (60 * index)<br />    y: 20 + (60 * index)<br />    width: 60<br />    height: 60<br /></pre></code></p>","source":"grayscale: function() {\n      return this.copy().grayscale$();\n    },","parameters":{},"returns":{"type":"Color","description":"A copy of the calling color converted to grayscale."},"see":""},"grayscale$":{"summary":"<p>The calling color converted to grayscale.</p>","code_sample":"<pre><code>color = Color(255, 255, 0)\n\n# modifies color into gray\ncolor.grayscale$()\n\ncolor.toString()\n# =&gt; 'rgba(128, 128, 128, 1)'\n</code></pre>","source":"grayscale$: function() {\n      var g, hsl;\n      hsl = this.toHsl();\n      g = (hsl[2] * 255).round();\n      this.r = this.g = this.b = g;\n      return this;\n    },","parameters":{},"returns":{"type":"Color","description":"The calling color converted to grayscale."},"see":""},"hue":{"summary":"<p>A getter / setter for the hue value of the color. Passing no argument returns the<br />current hue value. Passing a value will set the hue to that value and return the color.</p>","code_sample":"<p><code class=\"run\"><pre><br />magenta = Color(255, 0, 255)</p>\n\n<p>magenta.hue()</p>\n\n<h1>=> 300</h1>\n\n<h1>modifies the color to be yellow</h1>\n\n<p>magenta.hue(60)</p>\n\n<h1>to see what it looks like</h1>\n\n<p>canvas.drawRect<br />  color: magenta<br />  x: 50<br />  y: 30<br />  width: 80<br />  height: 80<br /></pre></code></p>","source":"hue: function(newVal) {\n      var hsl, _ref;\n      hsl = this.toHsl();\n      if (newVal != null) {\n        hsl[0] = newVal;\n        _ref = hslToRgb(hsl), this.r = _ref[0], this.g = _ref[1], this.b = _ref[2], this.a = _ref[3];\n        return this;\n      } else {\n        return hsl[0];\n      }\n    },","parameters":{"newVal":{"type":"Number","description":"the new hue value","optional":true}},"returns":{"type":"Color|Number","description":"returns the color object if you pass a new hue value and returns the hue otherwise"},"see":""},"lightness":{"summary":"<p>A getter / setter for the lightness value of the color. Passing no argument returns the<br />current lightness value. Passing a value will set the lightness to that value and return the color.</p>","code_sample":"<p><code class=\"run\"><pre><br />magenta = Color(255, 0, 255)</p>\n\n<p>magenta.lightness()</p>\n\n<h1>=> 0.9</h1>\n\n<h1>modifies magenta in place to be lighter</h1>\n\n<p>magenta.lightness(0.75)</p>\n\n<h1>to see what it looks like</h1>\n\n<p>canvas.drawRect<br />  color: magenta<br />  x: 50<br />  y: 30<br />  width: 80<br />  height: 80<br /></pre></code></p>","source":"lightness: function(newVal) {\n      var hsl, _ref;\n      hsl = this.toHsl();\n      if (newVal != null) {\n        hsl[2] = newVal;\n        _ref = hslToRgb(hsl), this.r = _ref[0], this.g = _ref[1], this.b = _ref[2], this.a = _ref[3];\n        return this;\n      } else {\n        return hsl[2];\n      }\n    },\n    value: function(newVal) {\n      var hsv, _ref;\n      hsv = this.toHsv();\n      if (newVal != null) {\n        hsv[2] = newVal;\n        _ref = hsvToRgb(hsv), this.r = _ref[0], this.g = _ref[1], this.b = _ref[2], this.a = _ref[3];\n        return this;\n      } else {\n        return hsv[2];\n      }\n    },","parameters":{"newVal":{"type":"Number","description":"the new lightness value","optional":true}},"returns":{"type":"Color|Number","description":"returns the color object if you pass a new lightness value and returns the lightness otherwise"},"see":""},"shiftHue":{"summary":"<p>A copy of the calling color with its hue shifted by <code>degrees</code>. This differs from the hue setter in that it adds to the existing hue value and will wrap around 0 and 360.</p>","code_sample":"<p><code class=\"run\"><pre><br />magenta = Color(255, 0, 255)</p>\n\n<p>magenta.hue()</p>\n\n<h1>=> 300</h1>\n\n<p>yellow = magenta.shiftHue(120)</p>\n\n<h1>since magenta's hue is 300 we have wrapped</h1>\n\n<h1>around 360 to end up at 60</h1>\n\n<p>yellow.hue()</p>\n\n<h1>=> 60</h1>\n\n<h1>to see what they look like</h1>\n\n<p>for color, index in [magenta, yellow]<br />  canvas.drawRect<br />    color: color<br />    x: 20 + (60 * index)<br />    y: 20 + (60 * index)<br />    width: 60<br />    height: 60<br /></pre></code></p>","source":"shiftHue: function(degrees) {\n      return this.copy().shiftHue$(degrees);\n    },","parameters":{"degrees":{"type":"Number","description":"number of degrees to shift the hue on the color wheel.","optional":false}},"returns":{"type":"Color","description":"A copy of the color with its hue shifted by `degrees`"},"see":""},"shiftHue$":{"summary":"<p>The calling color with its hue shifted by <code>degrees</code>. This differs from the hue setter in that it adds to the existing hue value and will wrap around 0 and 360.</p>","code_sample":"<pre><code>magenta = Color(255, 0, 255)\n\nmagenta.hue()\n# =&gt; 300\n\nmagenta.shiftHue$(120)\n\n# since magenta's hue is 300 we have wrapped\n# around 360 to end up at 60. Also we have\n# modified magenta in place to become yellow\nmagenta.hue()\n# =&gt; 60\n\nmagenta.toString()\n# =&gt; 'rgba(255, 255, 0, 1)'\n</code></pre>","source":"shiftHue$: function(degrees) {\n      var hsl, _ref;\n      hsl = this.toHsl();\n      hsl[0] = (hsl[0] + degrees.round()).mod(360);\n      _ref = hslToRgb(hsl), this.r = _ref[0], this.g = _ref[1], this.b = _ref[2], this.a = _ref[3];\n      return this;\n    },","parameters":{"degrees":{"type":"Number","description":"number of degrees to shift the hue on the color wheel.","optional":false}},"returns":{"type":"Color","description":"The color with its hue shifted by `degrees`"},"see":""},"lighten":{"summary":"<p>Returns a copy of the calling color lightened by <code>amount</code> (Lightness of the color ranges from 0 to 1).</p>","code_sample":"<p><code class=\"run\"><pre><br />green = Color(0, 255, 0)</p>\n\n<p>lightGreen = green.lighten(0.3)</p>\n\n<h1>to see what they look like</h1>\n\n<p>for color, index in [green, lightGreen]<br />  canvas.drawRect<br />    color: color<br />    x: 20 + (60 * index)<br />    y: 20 + (60 * index)<br />    width: 60<br />    height: 60<br /></pre></code></p>","source":"lighten: function(amount) {\n      return this.copy().lighten$(amount);\n    },","parameters":{"amount":{"type":"Number","description":"Amount to lighten color by (between 0 to 1)","optional":false}},"returns":{"type":"Color","description":"A new color. The lightness value is increased by `amount` from the original."},"see":""},"lighten$":{"summary":"<p>The calling color lightened by <code>amount</code> (Lightness of the color ranges from 0 to 1).</p>","code_sample":"<pre><code>green = Color(0, 255, 0)\n\ngreen.lighten$(0.2)\n\n# we have modified green in place\n# to become lightGreen\ngreen.toString()\n</code></pre>\n\n<h1>=> 'rgba(102, 255, 102, 1)'</h1>","source":"lighten$: function(amount) {\n      var hsl, _ref;\n      hsl = this.toHsl();\n      hsl[2] += amount;\n      _ref = hslToRgb(hsl), this.r = _ref[0], this.g = _ref[1], this.b = _ref[2], this.a = _ref[3];\n      return this;\n    },","parameters":{"amount":{"type":"Number","description":"Amount to lighten color by (between 0 - 1)","optional":false}},"returns":{"type":"Color","description":"The calling color with its lightness value increased by `amount`."},"see":""},"mixWith":{"summary":"<p>A copy of the calling color mixed with <code>other</code> using <code>amount</code> as the<br />mixing ratio. If amount is not passed, then the colors are mixed evenly.</p>","code_sample":"<p><code class=\"run\"><pre><br />red = Color(255, 0, 0)<br />yellow = Color(255, 255, 0)</p>\n\n<h1>With no amount argument the colors are mixed evenly</h1>\n\n<p>orange = red.mixWith(yellow)</p>\n\n<h1>With an amount of 0.3 we are mixing the color 30% red and 70% yellow</h1>\n\n<p>somethingCloseToOrange = red.mixWith(yellow, 0.3)</p>\n\n<h1>to see what they look like</h1>\n\n<p>for color, index in [red, yellow, orange, somethingCloseToOrange]<br />  canvas.drawRect<br />    color: color<br />    x: 20 + (60 * (index % 2))<br />    y: 20 + (60 * (if index > 1 then 1 else 0))<br />    width: 60<br />    height: 60<br /></pre></code></p>","source":"mixWith: function(other, amount) {\n      return this.copy().mixWith$(other, amount);\n    },","parameters":{"other":{"type":"Color","description":"the other color to mix","optional":false},"amount":{"type":"Number","description":"the mixing ratio of the calling color to `other`","optional":true}},"returns":{"type":"Color","description":"A new color that is a mix of the calling color and `other`"},"see":""},"mixWith$":{"summary":"<p>A copy of the calling color mixed with <code>other</code> using <code>amount</code> as the<br />mixing ratio. If amount is not passed, then the colors are mixed evenly.</p>","code_sample":"<pre><code>red = Color(255, 0, 0)\nyellow = Color(255, 255, 0)\nanotherRed = Color(255, 0, 0)\n\n# With no amount argument the colors are mixed evenly\nred.mixWith$(yellow)\n\n# We have modified red in place to be orange\nred.toString()\n# =&gt; 'rgba(255, 128, 0, 1)'\n\n# With an amount of 0.3 we are mixing the color 30% red and 70% yellow\nanotherRed.mixWith$(yellow, 0.3)\n\n# We have modified `anotherRed` in place to be somethingCloseToOrange\nanotherRed.toString()\n# =&gt; rgba(255, 179, 0, 1)\n</code></pre>","source":"mixWith$: function(other, amount) {\n      var _ref, _ref2;\n      amount || (amount = 0.5);\n      _ref = [this.r, this.g, this.b, this.a].zip([other.r, other.g, other.b, other.a]).map(function(array) {\n        return (array[0] * amount) + (array[1] * (1 - amount));\n      }), this.r = _ref[0], this.g = _ref[1], this.b = _ref[2], this.a = _ref[3];\n      _ref2 = [this.r, this.g, this.b].map(function(color) {\n        return color.round();\n      }), this.r = _ref2[0], this.g = _ref2[1], this.b = _ref2[2];\n      return this;\n    },","parameters":{"other":{"type":"Color","description":"the other color to mix","optional":false},"amount":{"type":"Number","description":"the mixing ratio of the calling color to `other`","optional":true}},"returns":{"type":"Color","description":"The modified calling color after mixing it with `other`"},"see":""},"saturate":{"summary":"<p>A copy of the calling color with its saturation increased by <code>amount</code>.</p>","code_sample":"<p><code class=\"run\"><pre><br />color = Color(50, 50, 200)</p>\n\n<p>color.saturation()</p>\n\n<h1>=> 0.6</h1>\n\n<p>saturatedColor = color.saturate(0.2)</p>\n\n<p>saturatedColor.saturation()</p>\n\n<h1>=> 0.8</h1>\n\n<h1>to see what they look like</h1>\n\n<p>for color, index in [color, saturatedColor]<br />  canvas.drawRect<br />    color: color<br />    x: 20 + (60 * index)<br />    y: 20 + (60 * index)<br />    width: 60<br />    height: 60<br /></pre></code></p>","source":"saturate: function(amount) {\n      return this.copy().saturate$(amount);\n    },","parameters":{"amount":{"type":"Number","description":"the amount to increase saturation by","optional":false}},"returns":{"type":"Color","description":"A copy of the calling color with its saturation increased by `amount`"},"see":""},"saturate$":{"summary":"<p>The calling color with its saturation increased by <code>amount</code>.</p>","code_sample":"<pre><code>color = Color(50, 50, 200)\n\ncolor.saturation()\n# =&gt; 0.6\n\ncolor.saturate$(0.2)\n\n# We have modified color in place and increased its saturation to 0.8\ncolor.saturation()\n# =&gt; 0.8\n\ncolor.toString()\n# =&gt; rgba(25, 25, 225, 1)\n</code></pre>","source":"saturate$: function(amount) {\n      var hsl, _ref;\n      hsl = this.toHsl();\n      hsl[1] += amount;\n      _ref = hslToRgb(hsl), this.r = _ref[0], this.g = _ref[1], this.b = _ref[2], this.a = _ref[3];\n      return this;\n    },","parameters":{"amount":{"type":"Number","description":"the amount to increase saturation by","optional":false}},"returns":{"type":"Color","description":"The calling color with its saturation increased by `amount`"},"see":""},"saturation":{"summary":"<p>A getter / setter for the saturation value of the color. Passing no argument returns the<br />current saturation value. Passing a value will set the saturation to that value and return the color.</p>","code_sample":"<p><code class=\"run\"><pre><br />yellow = Color('hsl(60, 0.5, 0.5)')</p>\n\n<p>yellow.saturation()</p>\n\n<h1>=> 0.5</h1>\n\n<p>yellow.saturation(0.8)</p>\n\n<h1>to see what it looks like</h1>\n\n<p>canvas.drawRect<br />  color: yellow<br />  x: 50<br />  y: 30<br />  width: 80<br />  height: 80<br /></pre></code></p>","source":"saturation: function(newVal, mode) {\n      var hsl, hsv, _ref, _ref2;\n      if (mode === 'hsv') {\n        hsv = this.toHsv();\n        if (newVal != null) {\n          hsv[1] = newVal;\n          _ref = hsvToRgb(hsv), this.r = _ref[0], this.g = _ref[1], this.b = _ref[2], this.a = _ref[3];\n          return this;\n        } else {\n          return hsv[1];\n        }\n      } else {\n        hsl = this.toHsl();\n        if (newVal != null) {\n          hsl[1] = newVal;\n          _ref2 = hslToRgb(hsl), this.r = _ref2[0], this.g = _ref2[1], this.b = _ref2[2], this.a = _ref2[3];\n          return this;\n        } else {\n          return hsl[1];\n        }\n      }\n    },","parameters":{"newVal":{"type":"Number","description":"the new saturation value","optional":true}},"returns":{"type":"Color|Number","description":"returns the color object if you pass a new saturation value and returns the saturation otherwise"},"see":""},"toHex":{"summary":"<p>returns the Hex representation of the color. Exclude the leading <code>#</code> by passing false.</p>","code_sample":"<pre><code>color = Color('hsl(60, 1, 0.5)')\n\n# passing nothing will leave the `#` intact\ncolor.toHex()\n# =&gt; '#ffff00'\n\n# passing false will remove the `#`\ncolor.toHex(false)\n# =&gt; 'ffff00'\n</code></pre>","source":"toHex: function(leadingHash) {\n      var hexFromNumber, padString;\n      padString = function(hexString) {\n        var pad;\n        if (hexString.length === 1) {\n          pad = \"0\";\n        } else {\n          pad = \"\";\n        }\n        return pad + hexString;\n      };\n      hexFromNumber = function(number) {\n        return padString(number.toString(16));\n      };\n      if (leadingHash === false) {\n        return \"\" + (hexFromNumber(this.r)) + (hexFromNumber(this.g)) + (hexFromNumber(this.b));\n      } else {\n        return \"#\" + (hexFromNumber(this.r)) + (hexFromNumber(this.g)) + (hexFromNumber(this.b));\n      }\n    },","parameters":{"leadingHash":{"type":"Boolean","description":"if passed as false excludes the leading `#` from the string","optional":true}},"returns":{"type":"String","description":"returns the Hex representation of the color"},"see":""},"toHsl":{"summary":"<p>returns an array of the hue, saturation, lightness, and alpha values of the color.</p>","code_sample":"<pre><code>magenta = Color(255, 0, 255)\n\nmagenta.toHsl()\n# =&gt; [300, 1, 0.5, 1]\n</code></pre>","source":"toHsl: function() {\n      var b, channel, chroma, g, hue, lightness, max, min, r, saturation, _ref, _ref2;\n      _ref = (function() {\n        var _i, _len, _ref, _results;\n        _ref = [this.r, this.g, this.b];\n        _results = [];\n        for (_i = 0, _len = _ref.length; _i < _len; _i++) {\n          channel = _ref[_i];\n          _results.push(channel / 255);\n        }\n        return _results;\n      }).call(this), r = _ref[0], g = _ref[1], b = _ref[2];\n      _ref2 = [r, g, b].extremes(), min = _ref2.min, max = _ref2.max;\n      hue = saturation = lightness = (max + min) / 2;\n      chroma = max - min;\n      if (chroma.abs() < 0.00001) {\n        hue = saturation = 0;\n      } else {\n        saturation = lightness > 0.5 ? chroma / (1 - lightness) : chroma / lightness;\n        saturation /= 2;\n        switch (max) {\n          case r:\n            hue = ((g - b) / chroma) + 0;\n            break;\n          case g:\n            hue = ((b - r) / chroma) + 2;\n            break;\n          case b:\n            hue = ((r - g) / chroma) + 4;\n        }\n        hue = (hue * 60).mod(360);\n      }\n      return [hue, saturation, lightness, this.a];\n    },\n    toHsv: function() {\n      var b, d, g, h, max, min, r, s, v, _ref;\n      r = this.r / 255;\n      g = this.g / 255;\n      b = this.b / 255;\n      _ref = [r, g, b].extremes(), min = _ref.min, max = _ref.max;\n      h = s = v = max;\n      d = max - min;\n      s = (max === 0 ? 0 : d / max);\n      if (max === min) {\n        h = 0;\n      } else {\n        switch (max) {\n          case r:\n            h = (g - b) / d + (g < b ? 6 : 0);\n            break;\n          case g:\n            h = (b - r) / d + 2;\n            break;\n          case b:\n            h = (r - g) / d + 4;\n        }\n        h *= 60;\n      }\n      return [h, s, v];\n    },","parameters":{},"returns":{"type":"Array","description":"An array of the hue, saturation, lightness, and alpha values of the color."},"see":""},"toString":{"summary":"<p>returns string rgba representation of the color.</p>","code_sample":"<pre><code>red = Color('#ff0000')\n\nred.toString()\n# =&gt; 'rgba(255, 0, 0, 1)'\n</code></pre>","source":"toString: function() {\n      return \"rgba(\" + this.r + \", \" + this.g + \", \" + this.b + \", \" + this.a + \")\";\n    },","parameters":{},"returns":{"type":"String","description":"The rgba string representation of the color"},"see":""},"transparentize":{"summary":"<p>A copy of the calling color with its alpha reduced by <code>amount</code>.</p>","code_sample":"<p><code class=\"run\"><pre><br />color = Color(0, 0, 0, 1)</p>\n\n<p>color.a</p>\n\n<h1>=> 1</h1>\n\n<p>transparentColor = color.transparentize(0.5)</p>\n\n<p>transparentColor.a</p>\n\n<h1>=> 0.5</h1>\n\n<h1>to see what they look like</h1>\n\n<p>for color, index in [color, transparentColor]<br />  canvas.drawRect<br />    color: color<br />    x: 20 + (60 * index)<br />    y: 20 + (60 * index)<br />    width: 60<br />    height: 60<br /></pre></code></p>","source":"transparentize: function(amount) {\n      return this.copy().transparentize$(amount);\n    },","parameters":{},"returns":{"type":"Color","description":"A copy of the calling color with its alpha reduced by `amount`"},"see":""},"transparentize$":{"summary":"<p>The calling color with its alpha reduced by <code>amount</code>.</p>","code_sample":"<pre><code>color = Color(0, 0, 0, 1)\n\ncolor.a\n# =&gt; 1\n\n# We modify color in place\ncolor.transparentize$(0.5)\n\ncolor.a\n# =&gt; 0.5\n</code></pre>","source":"transparentize$: function(amount) {\n      this.a = (this.a - amount).clamp(0, 1);\n      return this;\n    },","parameters":{},"returns":{"type":"Color","description":"The calling color with its alpha reduced by `amount`"},"see":""},"opacify":{"summary":"<p>A copy of the calling color with its alpha increased by <code>amount</code>.</p>","code_sample":"<p><code class=\"run\"><pre><br />color = Color(0, 0, 0, 0.25)</p>\n\n<p>color.a</p>\n\n<h1>=> 0.25</h1>\n\n<p>opaqueColor = color.opacify(0.5)</p>\n\n<p>opaqueColor.a</p>\n\n<h1>=> 0.75</h1>\n\n<h1>to see what they look like</h1>\n\n<p>for color, index in [color, opaqueColor]<br />  canvas.drawRect<br />    color: color<br />    x: 20 + (60 * index)<br />    y: 20 + (60 * index)<br />    width: 60<br />    height: 60<br /></pre></code></p>","source":"opacify: function(amount) {\n      return this.copy().opacify$(amount);\n    },","parameters":{},"returns":{"type":"Color","description":"A copy of the calling color with its alpha increased by `amount`"},"see":""},"opacify$":{"summary":"<p>The calling color with its alpha increased by <code>amount</code>.</p>","code_sample":"<pre><code>color = Color(0, 0, 0, 0)\n\ncolor.a\n# =&gt; 0\n\n# We modify color in place\ncolor.opacify$(0.25)\n\ncolor.a\n# =&gt; 0.25\n</code></pre>","source":"opacify$: function(amount) {\n      this.a = (this.a + amount).clamp(0, 1);\n      return this;\n    }\n  };","parameters":{},"returns":{"type":"Color","description":"The calling color with its alpha increased by `amount`"},"see":""}}}},{"Color.":{"method_list":[],"methods":{}}},{"Controllable.":{"method_list":[],"methods":{}}},{"Cooldown.":{"method_list":[],"methods":{}}},{"Core#":{"method_list":["attrAccessor","attrReader","extend","include"],"methods":{"attrAccessor":{"summary":"<p>Generates a public jQuery style getter / setter method for each<br />String argument.</p>","code_sample":"<pre><code>myObject = Core\n  r: 255\n  g: 0\n  b: 100\n\nmyObject.attrAccessor \"r\", \"g\", \"b\"\n\nmyObject.r(254)\nmyObject.r()\n\n=&gt; 254\n</code></pre>","source":"attrAccessor: function() {\n      var attrNames;\n      attrNames = 1 <= arguments.length ? __slice.call(arguments, 0) : [];\n      return attrNames.each(function(attrName) {\n        return self[attrName] = function(newValue) {\n          if (newValue != null) {\n            I[attrName] = newValue;\n            return self;\n          } else {\n            return I[attrName];\n          }\n        };\n      });\n    },","parameters":{},"returns":{},"see":""},"attrReader":{"summary":"<p>Generates a public jQuery style getter method for each String argument.</p>","code_sample":"<pre><code>myObject = Core\n  r: 255\n  g: 0\n  b: 100\n\nmyObject.attrReader \"r\", \"g\", \"b\"\n\nmyObject.r()\n=&gt; 255\n\nmyObject.g()\n=&gt; 0\n\nmyObject.b()\n=&gt; 100\n</code></pre>","source":"attrReader: function() {\n      var attrNames;\n      attrNames = 1 <= arguments.length ? __slice.call(arguments, 0) : [];\n      return attrNames.each(function(attrName) {\n        return self[attrName] = function() {\n          return I[attrName];\n        };\n      });\n    },","parameters":{},"returns":{},"see":""},"extend":{"summary":"<p>Extends this object with methods from the passed in object. A shortcut for Object.extend(self, methods)</p>","code_sample":"<pre><code>I =\n  x: 30\n  y: 40\n  maxSpeed: 5\n\n# we are using extend to give player\n# additional methods that Core doesn't have\nplayer = Core(I).extend\n  increaseSpeed: -&gt;\n    I.maxSpeed += 1\n\nplayer.I.maxSpeed\n=&gt; 5\n\nplayer.increaseSpeed()\n\nplayer.I.maxSpeed\n=&gt; 6\n</code></pre>","source":"extend: function(options) {\n      Object.extend(self, options);\n      return self;\n    },","parameters":{},"returns":{"type":"self","description":""},"see":"Object.extend"},"include":{"summary":"<p>Includes a module in this object.</p>","code_sample":"<pre><code>myObject = Core()\nmyObject.include(Bindable)\n\n# now you can bind handlers to functions\nmyObject.bind \"someEvent\", -&gt;\n  alert(\"wow. that was easy.\")\n</code></pre>","source":"include: function() {\n      var Module, modules, _i, _len;\n      modules = 1 <= arguments.length ? __slice.call(arguments, 0) : [];\n      for (_i = 0, _len = modules.length; _i < _len; _i++) {\n        Module = modules[_i];\n        self.extend(Module(I, self));\n      }\n      return self;\n    }\n  };\n};\n;\nvar __slice = Array.prototype.slice;\n\nFunction.prototype.once = function() {\n  var func, memo, ran;\n  func = this;\n  ran = false;\n  memo = void 0;\n  return function() {\n    if (ran) return memo;\n    ran = true;\n    return memo = func.apply(this, arguments);\n  };\n};\n\nFunction.prototype.withBefore = function(interception) {\n  var method;\n  method = this;\n  return function() {\n    interception.apply(this, arguments);\n    return method.apply(this, arguments);\n  };\n};\n\nFunction.prototype.withAfter = function(interception) {\n  var method;\n  method = this;\n  return function() {\n    var result;\n    result = method.apply(this, arguments);\n    interception.apply(this, arguments);\n    return result;\n  };\n};","parameters":{"Module":{"type":"Module","description":"the module to include. A module is a constructor that takes two parameters, I and self, and returns an object containing the public methods to extend the including object with.","optional":false}},"returns":{},"see":""}}}},{"Core.":{"method_list":[],"methods":{}}},{"Date#":{"method_list":["constructor","getDate","getDay","getFullYear","getHours","getMilliseconds","getMinutes","getMonth","getSeconds","getTime","getTimezoneOffset","getUTCDate","getUTCDay","getUTCFullYear","getUTCHours","getUTCMilliseconds","getUTCMinutes","getUTCMonth","getUTCSeconds","setDate","setFullYear","setHours","setMilliseconds","setMinutes","setMonth","setSeconds","setTime","setUTCDate","setUTCFullYear","setUTCHours","setUTCMilliseconds","setUTCMinutes","setUTCMonth","setUTCSeconds","toDateString","toJSON","toLocaleDateString","toLocaleString","toLocaleTimeString","toString","toTimeString","toUTCString"],"methods":{"constructor":{"summary":"<p>Returns a reference to the Date function that created the instance's prototype.<br />Note that the value of this property is a reference to the function itself, not<br />a string containing the function's name.</p>","code_sample":"","source":null,"parameters":{},"returns":{},"see":""},"getDate":{"summary":"<p>Returns the day of the month for the specified date according to local time.</p>","code_sample":"<p><code><br />getDate()<br /></code></p>","source":null,"parameters":{},"returns":{},"see":""},"getDay":{"summary":"<p>Returns the day of the week for the specified date according to local time.</p>","code_sample":"<p><code><br />getDay()<br /></code></p>","source":null,"parameters":{},"returns":{},"see":""},"getFullYear":{"summary":"<p>Returns the year of the specified date according to local time.</p>","code_sample":"<p><code><br />getFullYear()<br /></code></p>","source":null,"parameters":{},"returns":{},"see":""},"getHours":{"summary":"<p>Returns the hour for the specified date according to local time.</p>","code_sample":"<p><code><br />getHours()<br /></code></p>","source":null,"parameters":{},"returns":{},"see":""},"getMilliseconds":{"summary":"<p>Returns the milliseconds in the specified date according to local time.</p>","code_sample":"<p><code><br />getMilliseconds()<br /></code></p>","source":null,"parameters":{},"returns":{},"see":""},"getMinutes":{"summary":"<p>Returns the minutes in the specified date according to local time.</p>","code_sample":"<p><code><br />getMinutes()<br /></code></p>","source":null,"parameters":{},"returns":{},"see":""},"getMonth":{"summary":"<p>Returns the month in the specified date according to local time.</p>","code_sample":"<p><code><br />getMonth()<br /></code></p>","source":null,"parameters":{},"returns":{},"see":""},"getSeconds":{"summary":"<p>Returns the seconds in the specified date according to local time.</p>","code_sample":"<p><code><br />getSeconds()<br /></code></p>","source":null,"parameters":{},"returns":{},"see":""},"getTime":{"summary":"<p>Returns the numeric value corresponding to the time for the specified date<br />according to universal time.</p>","code_sample":"<p><code> getTime() </code></p>","source":null,"parameters":{},"returns":{},"see":""},"getTimezoneOffset":{"summary":"<p>Returns the time-zone offset from UTC, in minutes, for the current locale.</p>","code_sample":"<p><code> getTimezoneOffset() </code></p>","source":null,"parameters":{},"returns":{},"see":""},"getUTCDate":{"summary":"<p>Returns the day (date) of the month in the specified date according to universal<br />time.</p>","code_sample":"<p><code><br />getUTCDate()<br /></code></p>","source":null,"parameters":{},"returns":{},"see":""},"getUTCDay":{"summary":"<p>Returns the day of the week in the specified date according to universal time.</p>","code_sample":"<p><code><br />getUTCDay()<br /></code></p>","source":null,"parameters":{},"returns":{},"see":""},"getUTCFullYear":{"summary":"<p>Returns the year in the specified date according to universal time.</p>","code_sample":"<p><code><br />getUTCFullYear()<br /></code></p>","source":null,"parameters":{},"returns":{},"see":""},"getUTCHours":{"summary":"<p>Returns the hours in the specified date according to universal time.</p>","code_sample":"<p><code><br />getUTCHours<br /></code></p>","source":null,"parameters":{},"returns":{},"see":""},"getUTCMilliseconds":{"summary":"<p>Returns the milliseconds in the specified date according to universal time.</p>","code_sample":"<p><code><br />getUTCMilliseconds()<br /></code></p>","source":null,"parameters":{},"returns":{},"see":""},"getUTCMinutes":{"summary":"<p>Returns the minutes in the specified date according to universal time.</p>","code_sample":"<p><code><br />getUTCMinutes()<br /></code></p>","source":null,"parameters":{},"returns":{},"see":""},"getUTCMonth":{"summary":"<p>Returns the month of the specified date according to universal time.</p>","code_sample":"<p><code><br />getUTCMonth()<br /></code></p>","source":null,"parameters":{},"returns":{},"see":""},"getUTCSeconds":{"summary":"<p>Returns the seconds in the specified date according to universal time.</p>","code_sample":"<p><code><br />getUTCSeconds()<br /></code></p>","source":null,"parameters":{},"returns":{},"see":""},"setDate":{"summary":"<p>Sets the day of the month for a specified date according to local time.</p>","code_sample":"<p><code> setDate(<em>dayValue</em>) </code></p>","source":null,"parameters":{"An":{"type":"dayValue","description":"integer from 1 to 31, representing the day of the month.","optional":false}},"returns":{},"see":""},"setFullYear":{"summary":"<p>Sets the full year for a specified date according to local time.</p>","code_sample":"<p><code><br />setFullYear(<i>yearValue</i>[, <i>monthValue</i>[, <em>dayValue</em>]])<br /></code></p>","source":null,"parameters":{"An":{"type":"dayValue","description":"integer between 1 and 31 representing the day of the","optional":false}},"returns":{},"see":""},"setHours":{"summary":"<p>Sets the hours for a specified date according to local time.</p>","code_sample":"<p><code><br />setHours(<i>hoursValue</i>[, <i>minutesValue</i>[, <i>secondsValue</i>[, <em>msValue</em>]]])<br /></code></p>","source":null,"parameters":{"An":{"type":"secondsValue","description":"integer between 0 and 59, representing the seconds. If","optional":false},"A":{"type":"msValue","description":"number between 0 and 999, representing the milliseconds. If","optional":false}},"returns":{},"see":""},"setMilliseconds":{"summary":"<p>Sets the milliseconds for a specified date according to local time.</p>","code_sample":"<p><code><br />setMilliseconds(<i>millisecondsValue</i>)<br /></code></p>","source":null,"parameters":{"A":{"type":"millisecondsValue","description":"number between 0 and 999, representing the","optional":false}},"returns":{},"see":""},"setMinutes":{"summary":"<p>Sets the minutes for a specified date according to local time.</p>","code_sample":"<p><code><br />setMinutes(<i>minutesValue</i>[, <i>secondsValue</i>[, <em>msValue</em>]])<br /></code></p>","source":null,"parameters":{"An":{"type":"secondsValue","description":"integer between 0 and 59, representing the seconds. If","optional":false},"A":{"type":"msValue","description":"number between 0 and 999, representing the milliseconds. If","optional":false}},"returns":{},"see":""},"setMonth":{"summary":"<p>Set the month for a specified date according to local time.</p>","code_sample":"<p><code><br />setMonth(<i>monthValue</i>[, <em>dayValue</em>])<br /></code></p>","source":null,"parameters":{"An":{"type":"dayValue","description":"integer from 1 to 31, representing the day of the month.","optional":false}},"returns":{},"see":""},"setSeconds":{"summary":"<p>Sets the seconds for a specified date according to local time.</p>","code_sample":"<p><code><br />setSeconds(<i>secondsValue</i>[, <em>msValue</em>])<br /></code></p>","source":null,"parameters":{"An":{"type":"secondsValue","description":"integer between 0 and 59.","optional":false},"A":{"type":"msValue","description":"number between 0 and 999, representing the milliseconds.","optional":false}},"returns":{},"see":""},"setTime":{"summary":"<p>Sets the Date object to the time represented by a number of milliseconds since<br />January 1, 1970, 00:00:00 UTC.</p>","code_sample":"<p><code><br />setTime(<i>timeValue</i>)<br /></code></p>","source":null,"parameters":{"An":{"type":"timeValue","description":"integer representing the number of milliseconds since 1","optional":false}},"returns":{},"see":""},"setUTCDate":{"summary":"<p>Sets the day of the month for a specified date according to universal time.</p>","code_sample":"<p><code><br />setUTCDate(<i>dayValue</i>)<br /></code></p>","source":null,"parameters":{"An":{"type":"dayValue","description":"integer from 1 to 31, representing the day of the month.","optional":false}},"returns":{},"see":""},"setUTCFullYear":{"summary":"<p>Sets the full year for a specified date according to universal time.</p>","code_sample":"<p><code><br />setUTCFullYear(<i>yearValue</i>[, <i>monthValue</i>[, <em>dayValue</em>]])<br /></code></p>","source":null,"parameters":{"An":{"type":"dayValue","description":"integer between 1 and 31 representing the day of the","optional":false}},"returns":{},"see":""},"setUTCHours":{"summary":"<p>Sets the hour for a specified date according to universal time.</p>","code_sample":"<p><code><br />setUTCHours(<i>hoursValue</i>[, <i>minutesValue</i>[, <i>secondsValue</i>[, <em>msValue</em>]]])<br /></code></p>","source":null,"parameters":{"An":{"type":"secondsValue","description":"integer between 0 and 59, representing the seconds. If","optional":false},"A":{"type":"msValue","description":"number between 0 and 999, representing the milliseconds. If","optional":false}},"returns":{},"see":""},"setUTCMilliseconds":{"summary":"<p>Sets the milliseconds for a specified date according to universal time.</p>","code_sample":"<p><code><br />setUTCMilliseconds(<i>millisecondsValue</i>)<br /></code></p>","source":null,"parameters":{"A":{"type":"millisecondsValue","description":"number between 0 and 999, representing the","optional":false}},"returns":{},"see":""},"setUTCMinutes":{"summary":"<p>Sets the minutes for a specified date according to universal time.</p>","code_sample":"<p><code><br />setUTCMinutes(<i>minutesValue</i>[, <i>secondsValue</i>[, <em>msValue</em>]])<br /></code></p>","source":null,"parameters":{"An":{"type":"secondsValue","description":"integer between 0 and 59, representing the seconds. If","optional":false},"A":{"type":"msValue","description":"number between 0 and 999, representing the milliseconds. If","optional":false}},"returns":{},"see":""},"setUTCMonth":{"summary":"<p>Sets the month for a specified date according to universal time.</p>","code_sample":"<p><code><br />setUTCMonth(<i>monthValue</i>[, <em>dayValue</em>])<br /></code></p>","source":null,"parameters":{"An":{"type":"dayValue","description":"integer from 1 to 31, representing the day of the month.","optional":false}},"returns":{},"see":""},"setUTCSeconds":{"summary":"<p>Sets the seconds for a specified date according to universal time.</p>","code_sample":"<p><code><br />setUTCSeconds(<i>secondsValue</i>[, <em>msValue</em>])<br /></code></p>","source":null,"parameters":{"An":{"type":"secondsValue","description":"integer between 0 and 59.","optional":false},"A":{"type":"msValue","description":"number between 0 and 999, representing the milliseconds.","optional":false}},"returns":{},"see":""},"toDateString":{"summary":"<p>Returns the date portion of a Date object in human readable form in American<br />English.</p>","code_sample":"<p><code><em>date</em>.toDateString()</code></p>","source":null,"parameters":{},"returns":{},"see":""},"toJSON":{"summary":"<p>Returns a JSON representation of the Date object.</p>","code_sample":"<p><code><em>date</em>.prototype.toJSON()</code></p>","source":null,"parameters":{},"returns":{},"see":""},"toLocaleDateString":{"summary":"<p>Converts a date to a string, returning the \"date\" portion using the operating<br />system's locale's conventions.</p>","code_sample":"<p><code><br />toLocaleDateString()<br /></code></p>","source":null,"parameters":{},"returns":{},"see":""},"toLocaleString":{"summary":"<p>Converts a date to a string, using the operating system's locale's conventions.</p>","code_sample":"<p><code><br />toLocaleString()<br /></code></p>","source":null,"parameters":{},"returns":{},"see":""},"toLocaleTimeString":{"summary":"<p>Converts a date to a string, returning the \"time\" portion using the current<br />locale's conventions.</p>","code_sample":"<p><code> toLocaleTimeString() </code></p>","source":null,"parameters":{},"returns":{},"see":""},"toString":{"summary":"<p>Returns a string representing the specified Date object.</p>","code_sample":"<p><code> toString() </code></p>","source":null,"parameters":{},"returns":{},"see":""},"toTimeString":{"summary":"<p>Returns the time portion of a Date object in human readable form in American<br />English.</p>","code_sample":"<p><code><em>date</em>.toTimeString()</code></p>","source":null,"parameters":{},"returns":{},"see":""},"toUTCString":{"summary":"<p>Converts a date to a string, using the universal time convention.</p>","code_sample":"<p><code> toUTCString() </code></p>","source":";","parameters":{},"returns":{},"see":""}}}},{"Debuggable#":{"method_list":["debug","toggleDebug"],"methods":{"debug":{"summary":"<p>Enable debugging display for the calling GameObject.</p>","code_sample":"<pre><code>player = GameObject\n  x: 40\n  y: 14\n  spriteName: null\n  numericErrorProperty: NaN\n\nplayer.include Debuggable\n\n# sets up debug output for all player's properties\n# at the starting position (0, 0)\nplayer.debug\n  filter: 'all'\n\nplayer.I.y = 45\n\n# sets up debug output for only properties that have\n# changed since initialization. In this case only y\n# would be displayed.\nplayer.debug\n  filter: 'changed'\n\n# sets up debug output for properties that are &lt;code&gt;undefined&lt;/code&gt;,\n# &lt;code&gt;null&lt;/code&gt;, or &lt;code&gt;NaN&lt;/code&gt;. In this case spriteName and\n# numericErrorProperty would be displayed.\nplayer.debug\n  filter: 'undefined'\n\n# sets up debug output using all possible configuration options\nplayer.debug\n  bounds: true # set this to false to disable visual debugging of the object's bounding box\n  color: 'red' # color of debug text\n  filter: 'all'\n  x: 30 # x position to start printing debug information\n  y: 50 # y position to start printing debug information\n  velocity: true # set this to false to disable visual debugging of the object's velocity\n</code></pre>","source":"debug: function(options) {\n      var x, y;\n      if (options == null) options = {};\n      x = options.x, y = options.y;\n      if (x != null) I.debug.position.x = x;\n      if (y != null) I.debug.position.y = y;\n      Object.extend(I.debug, options);\n      return I.debug.enabled = true;\n    },","parameters":{"Options":{"type":"Object","description":"to configure debug output","optional":false},"bounds":{"type":"Boolean","description":"Whether or not to visually debug the object's bounds","optional":false},"color":{"type":"Color, String","description":"The color of the debug text","optional":false},"filter":{"type":"String","description":"Choices include 'all', 'changed', and 'undefined'","optional":false},"x":{"type":"Number","description":"The x position to start drawing the debug information","optional":false},"y":{"type":"Number","description":"The y position to start drawing the debug information","optional":false},"velocity":{"type":"Boolean","description":"Whether or not to visually debug the object's velocity","optional":false}},"returns":{},"see":""},"toggleDebug":{"summary":"<p>Toggle display of debug information.</p>","code_sample":"<pre><code>player = GameObject()\n\nplayer.include Debuggable\n\n# enables debug display\nplayer.debug()\n\n# disables debug display\nplayer.toggleDisable()\n\n# if false is passed to toggleDisplay, then debugging is disabled.\nplayer.toggleDisplay(false)\n\n# if true is passed to toggleDisplay, then debugging is enabled.\nplayer.toggleDisplay(true)\n</code></pre>","source":"toggleDebug: function(newVal) {\n      if (newVal != null) {\n        return I.debug.enabled = newVal;\n      } else {\n        return I.debug.enabled = !I.debug.enabled;\n      }\n    }\n  };\n};\n;","parameters":{"newVal":{"type":"Boolean","description":"If true is passed then debugging is enabled, if false is passed then debugging is disabled, if nothing is passed, then debug state is toggled.","optional":false}},"returns":{},"see":""}}}},{"Debuggable.":{"method_list":[],"methods":{}}},{"Drawable#":{"method_list":["draw","beforeTransform","afterTransform","transform"],"methods":{"draw":{"summary":"<p>Draw does not actually do any drawing itself, instead it triggers all of the draw events.<br />Listeners on the events do the actual drawing.</p>","code_sample":"","source":"draw: function(canvas) {\n      self.trigger('beforeTransform', canvas);\n      canvas.withTransform(self.transform(), function(canvas) {\n        self.trigger('beforeDraw', canvas);\n        self.trigger('draw', canvas);\n        return self.trigger('afterDraw', canvas);\n      });\n      self.trigger('afterTransform', canvas);\n      return self;\n    },","parameters":{},"returns":{"type":"self","description":""},"see":""},"beforeTransform":{"summary":"<p>Triggered before the object should be drawn. A canvas is passed as<br />the first argument. This does not apply the current transform.</p>","code_sample":"","source":null,"parameters":{"canvas":{"type":"PowerCanvas","description":"A reference to the canvas to draw on.","optional":false}},"returns":{},"see":""},"afterTransform":{"summary":"<p>Triggered after the object should be drawn. A canvas is passed as<br />the first argument. This applies the current transform.</p>","code_sample":"","source":"var Drawable;\n\nDrawable = function(I, self) {\n  var setSizeCallback, _ref;\n  I || (I = {});\n  Object.reverseMerge(I, {\n    alpha: 1,\n    color: \"#196\",\n    hflip: false,\n    vflip: false,\n    spriteName: null,\n    zIndex: 0\n  });\n  setSizeCallback = function(sprite) {\n    I.width = sprite.width;\n    return I.height = sprite.height;\n  };\n  if ((_ref = I.sprite) != null ? typeof _ref.isString === \"function\" ? _ref.isString() : void 0 : void 0) {\n    if (I.sprite.indexOf(\"data:\") === 0) {\n      I.sprite = Sprite.fromURL(I.sprite, setSizeCallback);\n    } else {\n      I.sprite = Sprite.loadByName(I.sprite, setSizeCallback);\n    }\n  } else if (I.spriteName) {\n    I.sprite = Sprite.loadByName(I.spriteName, setSizeCallback);\n  }\n  self.bind('draw', function(canvas) {\n    var previousAlpha, sprite;\n    if ((I.alpha != null) && I.alpha !== 1) {\n      previousAlpha = canvas.context().globalAlpha;\n      canvas.context().globalAlpha = I.alpha;\n    }\n    if (sprite = I.sprite) {\n      if (sprite.draw != null) {\n        sprite.draw(canvas, -sprite.width / 2, -sprite.height / 2);\n      } else {\n        if (typeof warn === \"function\") warn(\"Sprite has no draw method!\");\n      }\n    } else {\n      if (I.radius != null) {\n        canvas.drawCircle({\n          x: 0,\n          y: 0,\n          radius: I.radius,\n          color: I.color\n        });\n      } else {\n        canvas.drawRect({\n          x: -I.width / 2,\n          y: -I.height / 2,\n          width: I.width,\n          height: I.height,\n          color: I.color\n        });\n      }\n    }\n    if ((I.alpha != null) && I.alpha !== 1) {\n      return canvas.context().globalAlpha = previousAlpha;\n    }\n  });\n  return {","parameters":{"canvas":{"type":"PowerCanvas","description":"A reference to the canvas to draw on.","optional":false}},"returns":{},"see":""},"transform":{"summary":"<p>Returns the current transform, with translation, rotation, and flipping applied.</p>","code_sample":"","source":"transform: function() {\n      var center, transform;\n      center = self.center();\n      transform = Matrix.translation(center.x, center.y);\n      if ((I.scale != null) && I.scale !== 1) {\n        transform = transform.concat(Matrix.scale(I.scale));\n      }\n      if (I.rotation) transform = transform.concat(Matrix.rotation(I.rotation));\n      if (I.hflip) transform = transform.concat(Matrix.HORIZONTAL_FLIP);\n      if (I.vflip) transform = transform.concat(Matrix.VERTICAL_FLIP);\n      if (I.spriteOffset) {\n        transform = transform.concat(Matrix.translation(I.spriteOffset.x, I.spriteOffset.y));\n      }\n      return transform;\n    }\n  };\n};\n\nDrawable.setSizeCallback = function(sprite) {};\n;","parameters":{},"returns":{"type":"Matrix","description":"The current transform"},"see":""}}}},{"Drawable.":{"method_list":[],"methods":{}}},{"Durable.":{"method_list":[],"methods":{}}},{"Engine#":{"method_list":["beforeAdd","afterAdd","update","afterUpdate","beforeDraw","draw","overlay","start","stop","frameAdvance","play","pause","paused","setFramerate","collides","collidesWith","rayCollides","delay","nextLevel","goToLevel","reloadLevel","find","loadMap","add","cameras"],"methods":{"beforeAdd":{"summary":"<p>Observe or modify the<br />entity data before it is added to the engine.</p>","code_sample":"","source":null,"parameters":{"entityData":{"type":"Object","description":"","optional":false}},"returns":{},"see":""},"afterAdd":{"summary":"<p>Observe or configure a <code>gameObject</code> that has been added<br />to the engine.</p>","code_sample":"","source":null,"parameters":{"object":{"type":"GameObject","description":"The object that has just been added to the","optional":false}},"returns":{},"see":""},"update":{"summary":"<p>Called when the engine updates all the game objects.</p>","code_sample":"","source":null,"parameters":{},"returns":{},"see":""},"afterUpdate":{"summary":"<p>Called after the engine completes an update. Here it is<br />safe to modify the game objects array.</p>","code_sample":"","source":null,"parameters":{},"returns":{},"see":""},"beforeDraw":{"summary":"<p>Called before the engine draws the game objects on the canvas. The current camera transform is applied.</p>","code_sample":"","source":null,"parameters":{},"returns":{},"see":""},"draw":{"summary":"<p>Called after the engine draws on the canvas. The current camera transform is applied.</p>","code_sample":"<pre><code>engine.bind \"draw\", (canvas) -&gt;\n  # print some directions for the player\n  canvas.drawText\n    text: \"Go this way =&gt;\"\n    x: 200\n    y: 200\n</code></pre>","source":null,"parameters":{},"returns":{},"see":""},"overlay":{"summary":"<p>Called after the engine draws.</p>","code_sample":"<p>The current camera transform is not applied. This is great for<br />adding overlays.</p>\n\n<pre><code>engine.bind \"overlay\", (canvas) -&gt;\n  # print the player's health. This will be\n  # positioned absolutely according to the viewport.\n  canvas.drawText\n    text: \"HEALTH:\"\n    position: Point(20, 20)\n\n  canvas.drawText\n    text: player.health()\n    position: Point(50, 20)\n</code></pre>","source":"Engine = function(I) {\n    var animLoop, defaultModules, draw, frameAdvance, lastStepTime, modules, running, self, startTime, step, update;\n    if (I == null) I = {};\n    Object.reverseMerge(I, defaults);\n    frameAdvance = false;\n    running = false;\n    startTime = +new Date();\n    lastStepTime = -Infinity;\n    animLoop = function(timestamp) {\n      var delta, msPerFrame, remainder;\n      timestamp || (timestamp = +new Date());\n      msPerFrame = 1000 / I.FPS;\n      delta = timestamp - lastStepTime;\n      remainder = delta - msPerFrame;\n      if (remainder > 0) {\n        lastStepTime = timestamp - Math.min(remainder, msPerFrame);\n        step();\n      }\n      if (running) return window.requestAnimationFrame(animLoop);\n    };\n    update = function(elapsedTime) {\n      self.trigger(\"beforeUpdate\", elapsedTime);\n      self.trigger(\"update\", elapsedTime);\n      return self.trigger(\"afterUpdate\", elapsedTime);\n    };\n    draw = function() {\n      var canvas;\n      if (!(canvas = I.canvas)) return;\n      self.trigger(\"beforeDraw\", canvas);\n      self.trigger(\"draw\", canvas);\n      return self.trigger(\"overlay\", I.canvas);\n    };\n    step = function() {\n      var msPerFrame;\n      if (!I.paused || frameAdvance) {\n        msPerFrame = 1000 / I.FPS;\n        update(msPerFrame);\n        I.age += 1;\n      }\n      return draw();\n    };\n    self = Core(I).extend({","parameters":{},"returns":{},"see":""},"start":{"summary":"<p>Start the game simulation.</p>","code_sample":"<pre><code>engine.start()\n</code></pre>","source":"start: function() {\n        if (!running) {\n          running = true;\n          return window.requestAnimationFrame(animLoop);\n        }\n      },","parameters":{},"returns":{},"see":""},"stop":{"summary":"<p>Stop the simulation.</p>","code_sample":"<pre><code>engine.stop()\n</code></pre>","source":"stop: function() {\n        return running = false;\n      },","parameters":{},"returns":{},"see":""},"frameAdvance":{"summary":"<p>Pause the game and step through 1 update of the engine.</p>","code_sample":"<pre><code>engine.frameAdvance()\n</code></pre>","source":"frameAdvance: function() {\n        I.paused = true;\n        frameAdvance = true;\n        step();\n        return frameAdvance = false;\n      },","parameters":{},"returns":{},"see":""},"play":{"summary":"<p>Resume the game.</p>","code_sample":"<pre><code>engine.play()\n</code></pre>","source":"play: function() {\n        return I.paused = false;\n      },","parameters":{},"returns":{},"see":""},"pause":{"summary":"<p>Toggle the paused state of the simulation.</p>","code_sample":"<pre><code>engine.pause()\n</code></pre>","source":"pause: function(setTo) {\n        if (setTo != null) {\n          return I.paused = setTo;\n        } else {\n          return I.paused = !I.paused;\n        }\n      },","parameters":{"setTo":{"type":"Boolean","description":"Force to pause by passing true or unpause by passing false.","optional":true}},"returns":{},"see":""},"paused":{"summary":"<p>Query the engine to see if it is paused.</p>","code_sample":"<pre><code>engine.pause()\n\nengine.paused()\n# true\n\nengine.play()\n\nengine.paused()\n# false\n</code></pre>","source":"paused: function() {\n        return I.paused;\n      },","parameters":{},"returns":{},"see":""},"setFramerate":{"summary":"<p>Change the framerate of the game. The default framerate is 30 fps.</p>","code_sample":"<pre><code>engine.setFramerate(60)\n</code></pre>","source":"setFramerate: function(newFPS) {\n        I.FPS = newFPS;\n        self.stop();\n        return self.start();\n      },\n      update: update,\n      draw: draw\n    });\n    self.include(Bindable);\n    defaultModules = [\"Keyboard\", \"Mouse\", \"Background\", \"Delay\", \"GameState\", \"Selector\", \"Collision\"];\n    modules = defaultModules.concat(I.includedModules);\n    modules = modules.without([].concat(I.excludedModules));\n    modules.each(function(moduleName) {\n      if (!Engine[moduleName]) {\n        throw \"#Engine.\" + moduleName + \" is not a valid engine module\";\n      }\n      return self.include(Engine[moduleName]);\n    });\n    self.trigger(\"init\");\n    return self;\n  };\n  return (typeof exports !== \"undefined\" && exports !== null ? exports : this)[\"Engine\"] = Engine;\n})();\n;","parameters":{},"returns":{},"see":""},"collides":{"summary":"<p>Detects collisions between a bounds and the game objects.</p>","code_sample":"","source":"collides: function(bounds, sourceObject) {\n      return self.objects().inject(false, function(collided, object) {\n        return collided || (object.solid() && (object !== sourceObject) && object.collides(bounds));\n      });\n    },","parameters":{"The":{"type":"bounds","description":"bounds to check collisions with.","optional":false},"An":{"type":"[sourceObject]","description":"object to exclude from the results.","optional":false}},"returns":{"type":"Boolean","description":"true if the bounds object collides with any of the game objects, false otherwise."},"see":""},"collidesWith":{"summary":"<p>Detects collisions between a bounds and the game objects.<br />Returns an array of objects colliding with the bounds provided.</p>","code_sample":"","source":"collidesWith: function(bounds, sourceObject) {\n      var collided;\n      collided = [];\n      self.objects().each(function(object) {\n        if (!object.solid()) return;\n        if (object !== sourceObject && object.collides(bounds)) {\n          return collided.push(object);\n        }\n      });\n      if (collided.length) return collided;\n    },","parameters":{"The":{"type":"bounds","description":"bounds to check collisions with.","optional":false},"An":{"type":"[sourceObject]","description":"object to exclude from the results.","optional":false}},"returns":{"type":"Array","description":"An array of objects that collide with the given bounds."},"see":""},"rayCollides":{"summary":"<p>Detects collisions between a ray and the game objects.</p>","code_sample":"","source":"rayCollides: function(source, direction, sourceObject) {\n      var hits, nearestDistance, nearestHit;\n      hits = self.objects().map(function(object) {\n        var hit;\n        hit = object.solid() && (object !== sourceObject) && Collision.rayRectangle(source, direction, object.centeredBounds());\n        if (hit) hit.object = object;\n        return hit;\n      });\n      nearestDistance = Infinity;\n      nearestHit = null;\n      hits.each(function(hit) {\n        var d;\n        if (hit && (d = hit.distance(source)) < nearestDistance) {\n          nearestDistance = d;\n          return nearestHit = hit;\n        }\n      });\n      return nearestHit;\n    }\n  };\n};\n;","parameters":{"The":{"type":"source","description":"origin point","optional":false},"A":{"type":"direction","description":"point representing the direction of the ray","optional":false},"An":{"type":"[sourceObject]","description":"object to exclude from the results.","optional":false}},"returns":{},"see":""},"delay":{"summary":"<p>Execute a callback after a number of steps have passed.</p>","code_sample":"<pre><code>engine.delay 5, -&gt;\n  engine.add\n    class: \"Ghost\"\n</code></pre>","source":"delay: function(steps, callback) {\n      delayedEvents.push({\n        delay: steps,\n        callback: callback\n      });\n      return self;\n    }\n  };\n};\n;","parameters":{"steps":{"type":"Number","description":"The number of steps to wait before executing the callback","optional":false},"callback":{"type":"Function","description":"The callback to be executed.","optional":false}},"returns":{"type":"Engine","description":"self"},"see":""},"nextLevel":{"summary":"<p>Load map for the next level.</p>","code_sample":"<pre><code>engine.nextLevel()\n</code></pre>","source":"nextLevel: function() {\n      var level;\n      if (!I.transitioning) {\n        I.currentLevel += 1;\n        if (level = I.levels[I.currentLevel]) {\n          return loadLevel(level);\n        } else {\n          return engine.setState(GameOver());\n        }\n      }\n    },","parameters":{},"returns":{},"see":""},"goToLevel":{"summary":"<p>Load map named <code>level</code></p>","code_sample":"<pre><code>engine.goToLevel 'bossFight'\n</code></pre>","source":"goToLevel: function(level) {\n      return loadLevel(level);\n    },","parameters":{},"returns":{},"see":""},"reloadLevel":{"summary":"<p>Reload the current level. Useful for retrying after a player dies.</p>","code_sample":"<pre><code>engine.reloadLevel()\n</code></pre>","source":"reloadLevel: function() {\n      return loadLevel(I.currentLevelName);\n    }\n  };\n};\n;","parameters":{},"returns":{},"see":""},"find":{"summary":"<p>Get a selection of GameObjects that match the specified selector criteria. The selector language<br />can select objects by id, class, or attributes. Note that this method always returns an Array,<br />so if you are trying to find only one object you will need something like <code>engine.find(\"Enemy\").first()</code></p>","code_sample":"<pre><code>player = engine.add\n  class: \"Player\"\n\nenemy = engine.add\n  class: \"Enemy\"\n  speed: 5\n  x: 0\n\ndistantEnemy = engine.add\n  class \"Enemy\"\n  x: 500\n\nboss = engine.add\n  class: \"Enemy\"\n  id: \"Boss\"\n  x: 0\n\n# to select an object by id use \"#anId\"\nengine.find \"#Boss\"\n# =&gt; [boss]\n\n# to select an object by class use \"MyClass\"\nengine.find \"Enemy\"\n# =&gt; [enemy, distantEnemy, boss]\n\n# to select an object by properties use \".someProperty\" or \".someProperty=someValue\"\nengine.find \".speed=5\"\n# =&gt; [enemy]\n\n# You may mix and match selectors.\nengine.find \"Enemy.x=0\"\n# =&gt; [enemy, boss] # doesn't return distantEnemy\n</code></pre>","source":"each: function(selector, fn) {\n      return self.find(selector).each(function(obj, index) {\n        return fn(obj, index);\n      });\n    },\n    find: function(selector) {\n      var matcher, results;\n      results = [];\n      matcher = Engine.Selector.generate(selector);\n      self.objects().each(function(object) {\n        if (matcher.match(object)) return results.push(object);\n      });\n      return Object.extend(results, instanceMethods);\n    },\n    first: function(selector) {\n      return self.find(selector).first();\n    }\n  };\n};\n\nObject.extend(Engine.Selector, {\n  parse: function(selector) {\n    return selector.split(\",\").invoke(\"trim\");\n  },\n  process: function(item) {\n    var result;\n    result = /^(\\w+)?#?([\\w\\-]+)?\\.?([\\w\\-]+)?=?([\\w\\-]+)?/.exec(item);\n    if (result) {\n      if (result[4]) result[4] = result[4].parse();\n      return result.splice(1);\n    } else {\n      return [];\n    }\n  },\n  generate: function(selector) {\n    var ATTR, ATTR_VALUE, ID, TYPE, components;\n    components = Engine.Selector.parse(selector).map(function(piece) {\n      return Engine.Selector.process(piece);\n    });\n    TYPE = 0;\n    ID = 1;\n    ATTR = 2;\n    ATTR_VALUE = 3;\n    return {\n      match: function(object) {\n        var attr, attrMatch, component, idMatch, typeMatch, value, _i, _len;\n        for (_i = 0, _len = components.length; _i < _len; _i++) {\n          component = components[_i];\n          idMatch = (component[ID] === object.I.id) || !component[ID];\n          typeMatch = (component[TYPE] === object.I[\"class\"]) || !component[TYPE];\n          if (attr = component[ATTR]) {\n            if ((value = component[ATTR_VALUE]) != null) {\n              attrMatch = object.I[attr] === value;\n            } else {\n              attrMatch = object.I[attr];\n            }\n          } else {\n            attrMatch = true;\n          }\n          if (idMatch && typeMatch && attrMatch) return true;\n        }\n        return false;\n      }\n    };\n  }\n});\n;","parameters":{"selector":{"type":"String","description":"","optional":false}},"returns":{"type":"Array","description":"An array of the objects found"},"see":""},"loadMap":{"summary":"<p>Loads a new may and unloads any existing map or entities.</p>","code_sample":"","source":"loadMap: function(name, complete) {\n      clearObjects = updating;\n      return I.map = Tilemap.load({\n        name: name,\n        complete: complete,\n        entity: self.add\n      });\n    }\n  };\n};\n;","parameters":{},"returns":{},"see":""},"add":{"summary":"<p>The add method creates and adds an object to the game world. Two<br />other events are triggered around this one: beforeAdd and afterAdd.</p>","code_sample":"<pre><code># you can add arbitrary entityData and\n# the engine will make it into a GameObject\nengine.add\n  x: 50\n  y: 30\n  color: \"red\"\n\nplayer = engine.add\n  class: \"Player\"\n</code></pre>","source":"add: function(entityData) {\n      var object;\n      self.trigger(\"beforeAdd\", entityData);\n      object = GameObject.construct(entityData);\n      object.create();\n      self.trigger(\"afterAdd\", object);\n      if (I.updating) {\n        queuedObjects.push(object);\n      } else {\n        I.objects.push(object);\n      }\n      return object;\n    },\n    objects: function() {\n      return I.objects.copy();\n    }\n  });\n  self.include(Bindable);\n  self.bind(\"update\", function(elapsedTime) {\n    var toKeep, toRemove, _ref;\n    I.updating = true;\n    I.objects.invoke(\"trigger\", \"beforeUpdate\");\n    _ref = I.objects.partition(function(object) {\n      return object.update(elapsedTime);\n    }), toKeep = _ref[0], toRemove = _ref[1];\n    I.objects.invoke(\"trigger\", \"afterUpdate\");\n    toRemove.invoke(\"trigger\", \"remove\");\n    I.objects = toKeep.concat(queuedObjects);\n    queuedObjects = [];\n    return I.updating = false;\n  });\n  self.include(GameState.Cameras);\n  self.include(GameState.SaveState);\n  return self;\n};\n;\n\nGameState.Cameras = function(I, self) {\n  var cameras;\n  cameras = [Camera()];\n  self.bind('update', function() {\n    return self.cameras().invoke('trigger', 'update');\n  });\n  self.bind('afterUpdate', function() {\n    return self.cameras().invoke('trigger', 'afterUpdate');\n  });\n  self.bind('draw', function(canvas) {\n    return self.cameras().invoke('trigger', 'draw', canvas, self.objects());\n  });\n  self.bind('overlay', function(canvas) {\n    return self.cameras().invoke('trigger', 'overlay', canvas, self.objects());\n  });\n  return {\n    addCamera: function(data) {\n      return cameras.push(Camera(data));\n    },","parameters":{"entityData":{"type":"Object","description":"The data used to create the game object.","optional":false}},"returns":{"type":"GameObject","description":""},"see":""},"cameras":{"summary":"<p>Returns the array of camera objects.</p>","code_sample":"","source":"cameras: function(newCameras) {\n      if (newCameras) {\n        cameras = newCameras;\n        return self;\n      } else {\n        return cameras;\n      }\n    }\n  };\n};\n;","parameters":{},"returns":{"type":"Array","description":""},"see":""}}}},{"Engine.":{"method_list":[],"methods":{}}},{"Engine.Joysticks#":{"method_list":["controller"],"methods":{"controller":{"summary":"<p>Get a controller for a given joystick id.</p>","code_sample":"","source":"controller: function(i) {\n      return Joysticks.getController(i);\n    }\n  };\n};\n;","parameters":{"i":{"type":"Number","description":"The joystick id to get the controller of.","optional":false}},"returns":{},"see":""}}}},{"Fadeable#":{"method_list":["fadeOut"],"methods":{"fadeOut":{"summary":"<p>A convenient way to set the fade instance variables on a sprite. You can modify the<br />instance variables by hand but the suggested way to do it is through this method.</p>","code_sample":"<pre><code>player = GameObject()\n\nplayer.include(Fadeable)\n\nfadedOut = false\n\n# this will fade the player object out over the next 30 frames.\n# once the player is faded out the fadedOut variable will be set to true.\nplayer.fadeOut 30, (player) -&gt;\n  fadedOut = true\n\n30.times -&gt;\n  player.update()\n\nfadedOut\n# =&gt; true\n</code></pre>","source":"fadeOut: function(duration, callback) {\n      if (duration == null) duration = 30;\n      I.fadeDuration = duration;\n      I.fadeCooldown = duration;\n      return I.fadeCallback = callback;\n    }\n  };\n};\n;","parameters":{"duration=30":{"type":"Number","description":"How long the effect lasts","optional":true},"callback=null":{"type":"Function","description":"The function to execute when the sprite has finished fading.","optional":true}},"returns":{},"see":""}}}},{"Fadeable.":{"method_list":[],"methods":{}}},{"Flickerable#":{"method_list":["flicker"],"methods":{"flicker":{"summary":"<p>A convenient way to set the flicker instance variables on a sprite. You can modify the<br />instance variables by hand but the suggested way to do it is through this method.</p>","code_sample":"<pre><code>player = GameObject()\n\nplayer.include(Flickerable)\n\nplayer.flicker()\n# =&gt; This causes the sprite to flicker between full opacity\n# =&gt; and 50% opacity every 3 frames for 30 frames\n\nplayer.flicker(90, 5, 0.3)\n# =&gt; This causes the sprite to flicker between full opacity\n# =&gt; and 30% opacity every 5 frames for 90 frames\n</code></pre>","source":"flicker: function(_arg) {\n      var alpha, duration, frequency, _ref;\n      _ref = _arg != null ? _arg : {}, duration = _ref.duration, frequency = _ref.frequency, alpha = _ref.alpha;\n      if (duration != null) I.flickerDuration = duration;\n      if (frequency != null) I.flickerFrequency = frequency;\n      if (alpha != null) return I.flickerAlpha = alpha;\n    }\n  };\n};\n;","parameters":{"duration=30":{"type":"Number","description":"How long the effect lasts","optional":true},"frequency=3":{"type":"Number","description":"The number of frames in between opacity changes","optional":true},"alpha=0.5":{"type":"Number","description":"The alpha value to flicker to","optional":true}},"returns":{},"see":""}}}},{"Flickerable.":{"method_list":[],"methods":{}}},{"Follow#":{"method_list":["follow"],"methods":{"follow":{"summary":"<p>Set your velocity to follow another object.</p>","code_sample":"<pre><code>enemy.follow(player)\n\n# =&gt; The enemy now has it's velocity attribute set in\n# the direction of the player, with magnitude equal to\n# the enemy's speed\n</code></pre>","source":"follow: function(obj) {\n      if (obj) {\n        return I.velocity = obj.position().subtract(self.position()).norm(I.speed);\n      }\n    }\n  };\n};\n;","parameters":{"obj":{"type":"GameObject","description":"The object you want to follow","optional":false}},"returns":{},"see":""}}}},{"Follow.":{"method_list":[],"methods":{}}},{"Framerate#":{"method_list":["rendered"],"methods":{"rendered":{"summary":"<p>Call this method everytime you render.</p>","code_sample":"","source":"return self = {\n    rendered: function() {\n      var framerate, newTime, t;\n      if (renderTime < 0) {\n        return renderTime = new Date().getTime();\n      } else {\n        newTime = new Date().getTime();\n        t = newTime - renderTime;\n        framerate = 1000 / t;\n        framerates.push(framerate);\n        while (framerates.length > numFramerates) {\n          framerates.shift();\n        }\n        return renderTime = newTime;\n      }\n    }\n  };\n};\n;","parameters":{},"returns":{},"see":""}}}},{"Framerate.":{"method_list":[],"methods":{}}},{"Function#":{"method_list":["debounce","apply","bind","call","toString"],"methods":{"debounce":{"summary":"<p>Calling a debounced function will postpone its execution until after<br />wait milliseconds have elapsed since the last time the function was<br />invoked. Useful for implementing behavior that should only happen after<br />the input has stopped arriving. For example: rendering a preview of a<br />Markdown comment, recalculating a layout after the window has stopped<br />being resized...</p>","code_sample":"<pre><code>lazyLayout = calculateLayout.debounce(300)\n$(window).resize(lazyLayout)\n</code></pre>","source":"Function.prototype.debounce = function(wait) {\n  var func, timeout;\n  timeout = null;\n  func = this;\n  return function() {\n    var args, context, later;\n    context = this;\n    args = arguments;\n    later = function() {\n      timeout = null;\n      return func.apply(context, args);\n    };\n    clearTimeout(timeout);\n    return timeout = setTimeout(later, wait);\n  };\n};\n\nFunction.prototype.returning = function(x) {\n  var func;\n  func = this;\n  return function() {\n    func.apply(this, arguments);\n    return x;\n  };\n};\n\nFunction.prototype.delay = function() {\n  var args, func, wait;\n  wait = arguments[0], args = 2 <= arguments.length ? __slice.call(arguments, 1) : [];\n  func = this;\n  return setTimeout(function() {\n    return func.apply(null, args);\n  }, wait);\n};\n\nFunction.prototype.defer = function() {\n  var args;\n  args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];\n  return this.delay.apply(this, [1].concat(args));\n};\n;","parameters":{},"returns":{"type":"Function","description":"The debounced version of this function."},"see":""},"apply":{"summary":"<p>Calls a function with a given this value and arguments provided as an array.</p>","code_sample":"<p><code><em>fun</em>.apply(<em>thisArg</em>[, <em>argsArray</em>])</code></p>","source":null,"parameters":{"Determines":{"type":"thisArg","description":"the value of this inside fun. If thisArg is null or","optional":false},"An":{"type":"argsArray","description":"argument array for the object, specifying the arguments","optional":false}},"returns":{},"see":""},"bind":{"summary":"<p>Creates a new function that, when called, itself calls this function in the<br />context of the provided this value, with a given sequence of arguments preceding<br />any provided when the new function was called.</p>","code_sample":"<p><code><em>fun</em>.bind(<em>thisArg</em>[, <em>arg1</em>[, <em>arg2</em>[, ...]]])</code></p>","source":null,"parameters":{"arg2,":{"type":"thisValuearg1, ","description":"... The value to be passed as the this parameter to","optional":false}},"returns":{},"see":""},"call":{"summary":"<p>Calls a function with a given this value and arguments provided individually.</p>","code_sample":"<p><code><em>fun</em>.call(<em>thisArg</em>[, <em>arg1</em>[, <em>arg2</em>[, ...]]])</code></p>","source":null,"parameters":{"Determines":{"type":"thisArg","description":"the value of this inside fun. If thisArg is null or","optional":false},"arg2,":{"type":"arg1, ","description":"... Arguments for the object.","optional":false}},"returns":{},"see":""},"toString":{"summary":"<p>Returns a string representing the source code of the function.</p>","code_sample":"<p><code><em>function</em>.toString(<em>indentation</em>)</code></p>","source":null,"parameters":{"Non-standard":{"type":"indentation","description":"The amount of spaces to indent the string","optional":false}},"returns":{},"see":""}}}},{"GameObject#":{"method_list":["create","destroy","step","update","remove"],"methods":{"create":{"summary":"<p>Triggers the create event if the object has not already been created.</p>","code_sample":"","source":"create: function() {\n      if (!I.created) self.trigger('create');\n      return I.created = true;\n    },","parameters":{},"returns":{},"see":""},"destroy":{"summary":"<p>Destroys the object and triggers the destroyed event.</p>","code_sample":"","source":"destroy: function() {\n      if (!I.destroyed) self.trigger('destroy');\n      I.destroyed = true;\n      return I.active = false;\n    }\n  });\n  defaultModules = [Bindable, Bounded, Clampable, Cooldown, Drawable, Durable, Metered, TimedEvents, Tween];\n  modules = defaultModules.concat(I.includedModules.invoke('constantize'));\n  modules = modules.without(I.excludedModules.invoke('constantize'));\n  modules.each(function(Module) {\n    return self.include(Module);\n  });\n  self.attrAccessor(\"solid\");\n  autobindEvents = ['create', 'destroy', 'step'];\n  autobindEvents.each(function(eventName) {\n    var event;\n    if (event = I[eventName]) {\n      if (typeof event === \"function\") {\n        return self.bind(eventName, event);\n      } else {\n        return self.bind(eventName, eval(\"(function() {\" + event + \"})\"));\n      }\n    }\n  });\n  return self;\n};","parameters":{},"returns":{},"see":""},"step":{"summary":"<p>Triggered during every update step.</p>","code_sample":"<p>player = GameObject()</p>\n\n<pre><code>player.bind 'step', -&gt;\n  # check to see if keys are being pressed and\n  # change the player's velocity\n  if keydown.left\n    player.velocity(Point(-1, 0))\n  else if keydown.right\n    player.velocity(Point(1, 0))\n  else\n    player.velocity(Point(0, 0))\n</code></pre>","source":null,"parameters":{},"returns":{},"see":""},"update":{"summary":"<p>Update the game object. This is generally called by the engine.</p>","code_sample":"","source":"update: function(elapsedTime) {\n      if (I.active) {\n        self.trigger('step', elapsedTime);\n        self.trigger('update', elapsedTime);\n        I.age += 1;\n      }\n      return I.active;\n    },","parameters":{},"returns":{},"see":""},"remove":{"summary":"<p>Triggered when the object is removed from<br />the engine. Use the remove event to handle any clean up.</p>","code_sample":"<pre><code>boss = GameObject()\n\nboss.bind 'remove', -&gt;\n  unlockDoorToLevel2()\n</code></pre>","source":"var GameObject;\n\nGameObject = function(I) {\n  var autobindEvents, defaultModules, modules, self;\n  I || (I = {});","parameters":{},"returns":{},"see":""}}}},{"GameObject.":{"method_list":[],"methods":{}}},{"GameOver#":{"method_list":["update","overlay"],"methods":{"update":{"summary":"<p>Transitions to the title state on user input.</p>","code_sample":"","source":null,"parameters":{},"returns":{},"see":""},"overlay":{"summary":"<p>Draws Game Over screen and reset instructions.</p>","code_sample":"","source":"var GameOver;\n\nGameOver = function(I) {\n  var self;\n  if (I == null) I = {};\n  self = TextScreen(I);\n  self.bind('update', function() {\n    if (justPressed.any) {\n      return engine.delay(15, function() {\n        return engine.setState(TitleScreen());\n      });\n    }\n  });\n  self.bind(\"overlay\", function(canvas) {\n    self.centerText(canvas, \"Game Over\");\n    return self.centerText(canvas, \"Press any key to restart\", {\n      size: 12,\n      y: App.height / 2 + 30\n    });\n  });\n  return self;\n};\n;\nvar GameState;\n\nGameState = function(I) {\n  var queuedObjects, self;\n  if (I == null) I = {};\n  Object.reverseMerge(I, {\n    objects: []\n  });\n  queuedObjects = [];\n  self = Core(I).extend({","parameters":{"canvas":{"type":"PixieCanvas","description":"","optional":false}},"returns":{},"see":""}}}},{"GameOver.":{"method_list":[],"methods":{}}},{"GameState#":{"method_list":["saveState","loadState","reload"],"methods":{"saveState":{"summary":"<p>Save the current game state and returns a JSON object representing that state.</p>","code_sample":"<pre><code>engine.bind 'update', -&gt;\n  if justPressed.s\n    engine.saveState()\n</code></pre>","source":"saveState: function() {\n      return savedState = I.objects.map(function(object) {\n        return Object.extend({}, object.I);\n      });\n    },","parameters":{},"returns":{"type":"Array","description":"An array of the instance data of all objects in the game state"},"see":""},"loadState":{"summary":"<p>Loads the game state passed in, or the last saved state, if any.</p>","code_sample":"<pre><code>engine.bind 'update', -&gt;\n  if justPressed.l\n    # loads the last saved state\n    engine.loadState()\n\n  if justPressed.o\n    # removes all game objects, then reinstantiates\n    # them with the entityData passed in\n    engine.loadState([{x: 40, y: 50, class: \"Player\"}, {x: 0, y: 0, class: \"Enemy\"}, {x: 500, y: 400, class: \"Boss\"}])\n</code></pre>","source":"loadState: function(newState) {\n      if (newState || (newState = savedState)) {\n        I.objects.invoke(\"trigger\", \"remove\");\n        I.objects = [];\n        return newState.each(function(objectData) {\n          return self.add(Object.extend({}, objectData));\n        });\n      }\n    },","parameters":{"An":{"type":"[newState]","description":"arraf of object instance data to load.","optional":false}},"returns":{},"see":""},"reload":{"summary":"<p>Reloads the current game state, useful for hotswapping code.</p>","code_sample":"<pre><code>engine.I.objects.each (object) -&gt;\n  # bring all objects to (0, 0) for some reason\n  object.I.x = 0\n  object.I.y = 0\n\n# reload all objects to make sure\n# they are at (0, 0)\nengine.reload()\n</code></pre>","source":"reload: function() {\n      var oldObjects;\n      oldObjects = I.objects;\n      I.objects = [];\n      return oldObjects.each(function(object) {\n        object.trigger(\"remove\");\n        return self.add(object.I);\n      });\n    }\n  };\n};\n;","parameters":{},"returns":{},"see":""}}}},{"LevelState#":{"method_list":["enter"],"methods":{"enter":{"summary":"<p>Fades in the current level and loads the map.</p>","code_sample":"","source":"var LevelState;\n\nLevelState = function(I) {\n  var self;\n  if (I == null) I = {};\n  Object.reverseMerge(I, {\n    duration: 10,\n    level: 'level1'\n  });\n  self = GameState(I);\n  self.bind(\"enter\", function() {\n    engine.fadeIn({\n      duration: I.duration\n    });\n    return engine.loadMap(I.level, function() {\n      return engine.I.transitioning = false;\n    });\n  });\n  return self;\n};\n;","parameters":{},"returns":{},"see":""}}}},{"LevelState.":{"method_list":[],"methods":{}}},{"Math.":{"method_list":[],"methods":{}}},{"Matrix#":{"method_list":["concat","copy","deltaTransformPoint","inverse","rotate","scale","toString","transformPoint","translate"],"methods":{"concat":{"summary":"<p>Returns the result of this matrix multiplied by another matrix<br />combining the geometric effects of the two. In mathematical terms,<br />concatenating two matrixes is the same as combining them using matrix multiplication.<br />If this matrix is A and the matrix passed in is B, the resulting matrix is A x B<br /><a href='http://mathworld.wolfram.com/MatrixMultiplication.html'>http://mathworld.wolfram.com/MatrixMultiplication.html</a></p>","code_sample":"","source":"concat: function(matrix) {\n      return Matrix(this.a * matrix.a + this.c * matrix.b, this.b * matrix.a + this.d * matrix.b, this.a * matrix.c + this.c * matrix.d, this.b * matrix.c + this.d * matrix.d, this.a * matrix.tx + this.c * matrix.ty + this.tx, this.b * matrix.tx + this.d * matrix.ty + this.ty);\n    },","parameters":{"matrix":{"type":"Matrix","description":"The matrix to multiply this matrix by.","optional":false}},"returns":{"type":"Matrix","description":"The result of the matrix multiplication, a new matrix."},"see":""},"copy":{"summary":"<p>Copy this matrix.</p>","code_sample":"","source":"copy: function() {\n      return Matrix(this.a, this.b, this.c, this.d, this.tx, this.ty);\n    },","parameters":{},"returns":{"type":"Matrix","description":"A copy of this matrix."},"see":""},"deltaTransformPoint":{"summary":"<p>Given a point in the pretransform coordinate space, returns the coordinates of<br />that point after the transformation occurs. Unlike the standard transformation<br />applied using the transformPoint() method, the deltaTransformPoint() method<br />does not consider the translation parameters tx and ty.</p>","code_sample":"","source":"deltaTransformPoint: function(point) {\n      return Point(this.a * point.x + this.c * point.y, this.b * point.x + this.d * point.y);\n    },","parameters":{},"returns":{},"see":"#transformPoint"},"inverse":{"summary":"<p>Returns the inverse of the matrix.<br /><a href='http://mathworld.wolfram.com/MatrixInverse.html'>http://mathworld.wolfram.com/MatrixInverse.html</a></p>","code_sample":"","source":"inverse: function() {\n      var determinant;\n      determinant = this.a * this.d - this.b * this.c;\n      return Matrix(this.d / determinant, -this.b / determinant, -this.c / determinant, this.a / determinant, (this.c * this.ty - this.d * this.tx) / determinant, (this.b * this.tx - this.a * this.ty) / determinant);\n    },","parameters":{},"returns":{"type":"Matrix","description":"A new matrix that is the inverse of this matrix."},"see":""},"rotate":{"summary":"<p>Returns a new matrix that corresponds this matrix multiplied by a<br />a rotation matrix.</p>","code_sample":"","source":"rotate: function(theta, aboutPoint) {\n      return this.concat(Matrix.rotation(theta, aboutPoint));\n    },","parameters":{"theta":{"type":"Number","description":"Amount to rotate in radians.","optional":false},"aboutPoint":{"type":"Point","description":"The point about which this rotation occurs. Defaults to (0,0).","optional":true}},"returns":{"type":"Matrix","description":"A new matrix, rotated by the specified amount."},"see":"Matrix.rotation"},"scale":{"summary":"<p>Returns a new matrix that corresponds this matrix multiplied by a<br />a scaling matrix.</p>","code_sample":"","source":"scale: function(sx, sy, aboutPoint) {\n      return this.concat(Matrix.scale(sx, sy, aboutPoint));\n    },","parameters":{"sx":{"type":"Number","description":"","optional":false},"sy":{"type":"Number","description":"","optional":true},"aboutPoint":{"type":"Point","description":"The point that remains fixed during the scaling","optional":true}},"returns":{"type":"Matrix","description":"A new Matrix. The original multiplied by a scaling matrix."},"see":"Matrix.scale"},"toString":{"summary":"<p>Returns a string representation of this matrix.</p>","code_sample":"","source":"toString: function() {\n      return \"Matrix(\" + this.a + \", \" + this.b + \", \" + this.c + \", \" + this.d + \", \" + this.tx + \", \" + this.ty + \")\";\n    },","parameters":{},"returns":{"type":"String","description":"A string reperesentation of this matrix."},"see":""},"transformPoint":{"summary":"<p>Returns the result of applying the geometric transformation represented by the<br />Matrix object to the specified point.</p>","code_sample":"","source":"transformPoint: function(point) {\n      return Point(this.a * point.x + this.c * point.y + this.tx, this.b * point.x + this.d * point.y + this.ty);\n    },","parameters":{},"returns":{"type":"Point","description":"A new point with the transformation applied."},"see":"#deltaTransformPoint"},"translate":{"summary":"<p>Translates the matrix along the x and y axes, as specified by the tx and ty parameters.</p>","code_sample":"","source":"translate: function(tx, ty) {\n      return this.concat(Matrix.translation(tx, ty));\n    }\n  };","parameters":{"tx":{"type":"Number","description":"The translation along the x axis.","optional":false},"ty":{"type":"Number","description":"The translation along the y axis.","optional":false}},"returns":{"type":"Matrix","description":"A new matrix with the translation applied."},"see":"Matrix.translation"}}}},{"Matrix.":{"method_list":[],"methods":{}}},{"Metered#":{"method_list":["meter","showMeter","hideMeter","toggleMeter"],"methods":{"meter":{"summary":"<p>Configures a meter to be drawn each overlay event.</p>","code_sample":"<pre><code>player = GameObject\n\nplayer.include Metered\n\nplayer.meter 'health',\n  border\n    color: 'brown'\n    radius: 3\n  color: 'pink'\n  height: 20\n  x: 5\n  y: 5\n  show: true\n  width: 150\n\n# =&gt; Sets up a health meter, using all the configuration options\n</code></pre>","source":"meter: function(name, options) {\n      if (options == null) options = {};\n      Object.reverseMerge(options, {\n        backgroundColor: 'black',\n        border: {\n          color: 'white',\n          radius: 2,\n          width: 1.5\n        },\n        color: 'green',\n        height: 10,\n        x: 0,\n        y: 0,\n        show: true,\n        width: 100\n      });\n      if (I[name] == null) I[name] = 100;\n      if (!I[\"max\" + (name.capitalize())]) {\n        if (I[name]) {\n          I[\"max\" + (name.capitalize())] = I[name];\n        } else {\n          I[\"max\" + (name.capitalize())] = 100;\n        }\n      }\n      return I.meters[name] = options;\n    },","parameters":{"name":{"type":"String","description":"The name of the property to meter","optional":false},"options":{"type":"Object","description":"The meter configuration options","optional":false},"border:":{"type":"Number","description":"radius Border radius of the meter","optional":false},"color":{"type":"String","description":"Color of the meter's inner rectangle","optional":false},"height":{"type":"Number","description":"Height of the meter","optional":false},"position":{"type":"Object","description":"An x, y object representing the position of the meter","optional":false},"x":{"type":"Number","description":"x position of the meter","optional":false},"y":{"type":"Number","description":"y position of the meter","optional":false},"show":{"type":"Boolean","description":"Boolean to toggle whether of not to display the meter","optional":false},"width":{"type":"Number","description":"How wide the meter is","optional":false}},"returns":{},"see":""},"showMeter":{"summary":"<p>Shows the named meter</p>","code_sample":"<pre><code>player = GameObject\n\nplayer.include Metered\n\n# creates a health meter but disables visibility\nplayer.meter 'health'\n  show: false\n\n# enables visibility for the meter named 'health'\nplayer.showMeter 'health'\n</code></pre>","source":"showMeter: function(name) {\n      return I.meters[name].show = true;\n    },","parameters":{"name":{"type":"String","description":"The name of the meter to show","optional":false}},"returns":{},"see":""},"hideMeter":{"summary":"<p>Hides the named meter</p>","code_sample":"<pre><code>player = GameObject\n\nplayer.include Metered\n\n# creates a health meter\nplayer.meter 'health'\n\n# disables visibility for the meter named 'health'\nplayer.hideMeter 'health'\n</code></pre>","source":"hideMeter: function(name) {\n      return I.meters[name].show = false;\n    },","parameters":{"name":{"type":"String","description":"The name of the meter to hide","optional":false}},"returns":{},"see":""},"toggleMeter":{"summary":"<p>Toggles visibility of the named meter</p>","code_sample":"<pre><code>player = GameObject\n\nplayer.include Metered\n\n# creates a health meter\nplayer.meter 'health'\n\n# toggles visibility for the meter named 'health'\nplayer.toggleMeter 'health'\n</code></pre>","source":"toggleMeter: function(name) {\n      return I.meters[name].show = !I.meters[name].show;\n    }\n  };\n};\n;","parameters":{"name":{"type":"String","description":"The name of the meter to toggle","optional":false}},"returns":{},"see":""}}}},{"Metered.":{"method_list":[],"methods":{}}},{"Movable.":{"method_list":[],"methods":{}}},{"Number#":{"method_list":["abs","ceil","floor","round","circularPoint","clamp","mod","sign","even","odd","times","snap","primeFactors","toColorPart","approach","approachByRatio","approachRotation","constrainRotation","d","toExponential","toFixed","toLocaleString","toPrecision","toString","valueOf"],"methods":{"abs":{"summary":"<p>Returns the absolute value of this number.</p>","code_sample":"<pre><code>(-4).abs()\n# =&gt; 4\n</code></pre>","source":"Number.prototype.abs = function() {\n  return Math.abs(this);\n};","parameters":{},"returns":{"type":"Number","description":"The absolute value of the number."},"see":""},"ceil":{"summary":"<p>Returns the mathematical ceiling of this number.</p>","code_sample":"<pre><code>4.9.ceil()\n# =&gt; 5\n\n4.2.ceil()\n# =&gt; 5\n\n(-1.2).ceil()\n# =&gt; -1\n</code></pre>","source":"Number.prototype.ceil = function() {\n  return Math.ceil(this);\n};","parameters":{},"returns":{"type":"Number","description":"The number truncated to the nearest integer of greater than or equal value."},"see":""},"floor":{"summary":"<p>Returns the mathematical floor of this number.</p>","code_sample":"<pre><code>4.9.floor()\n# =&gt; 4\n\n4.2.floor()\n# =&gt; 4\n\n(-1.2).floor()\n# =&gt; -2\n</code></pre>","source":"Number.prototype.floor = function() {\n  return Math.floor(this);\n};","parameters":{},"returns":{"type":"Number","description":"The number truncated to the nearest integer of less than or equal value."},"see":""},"round":{"summary":"<p>Returns this number rounded to the nearest integer.</p>","code_sample":"<pre><code>4.5.round()\n# =&gt; 5\n\n4.4.round()\n# =&gt; 4\n</code></pre>","source":"Number.prototype.round = function() {\n  return Math.round(this);\n};","parameters":{},"returns":{"type":"Number","description":"The number rounded to the nearest integer."},"see":""},"circularPoint":{"summary":"<p>Get a bunch of points equally spaced around the unit circle.</p>","code_sample":"<pre><code>4.circularPoints (p) -&gt;\n\n# p gets Point(1, 0), Point(0, 1), Point(-1, 0), Point(0, -1)\n</code></pre>","source":"Number.prototype.circularPoints = function(block) {\n  var n;\n  n = this;\n  return n.times(function(i) {\n    return block(Point.fromAngle((i / n).turns), i);\n  });\n};","parameters":{},"returns":{},"see":""},"clamp":{"summary":"<p>Returns a number whose value is limited to the given range.</p>","code_sample":"<pre><code># limit the output of this computation to between 0 and 255\n(2 * 255).clamp(0, 255)\n# =&gt; 255\n</code></pre>","source":"Number.prototype.clamp = function(min, max) {\n  if ((min != null) && (max != null)) {\n    return Math.min(Math.max(this, min), max);\n  } else if (min != null) {\n    return Math.max(this, min);\n  } else if (max != null) {\n    return Math.min(this, max);\n  } else {\n    return this;\n  }\n};","parameters":{"min":{"type":"Number","description":"The lower boundary of the output range","optional":false},"max":{"type":"Number","description":"The upper boundary of the output range","optional":false}},"returns":{"type":"Number","description":"A number in the range [min, max]"},"see":""},"mod":{"summary":"<p>A mod method useful for array wrapping. The range of the function is<br />constrained to remain in bounds of array indices.</p>","code_sample":"<pre><code>(-1).mod(5)\n# =&gt; 4\n</code></pre>","source":"Number.prototype.mod = function(base) {\n  var result;\n  result = this % base;\n  if (result < 0 && base > 0) result += base;\n  return result;\n};","parameters":{"base":{"type":"Number","description":"","optional":false}},"returns":{"type":"Number","description":"An integer between 0 and (base - 1) if base is positive."},"see":""},"sign":{"summary":"<p>Get the sign of this number as an integer (1, -1, or 0).</p>","code_sample":"<pre><code>(-5).sign()\n# =&gt; -1\n\n0.sign()\n# =&gt; 0\n\n5.sign()\n# =&gt; 1\n</code></pre>","source":"Number.prototype.sign = function() {\n  if (this > 0) {\n    return 1;\n  } else if (this < 0) {\n    return -1;\n  } else {\n    return 0;\n  }\n};","parameters":{},"returns":{"type":"Number","description":"The sign of this number, 0 if the number is 0."},"see":""},"even":{"summary":"<p>Returns true if this number is even (evenly divisible by 2).</p>","code_sample":"<pre><code>2.even()\n# =&gt; true\n\n3.even()\n# =&gt; false\n\n0.even()\n# =&gt; true\n</code></pre>","source":"Number.prototype.even = function() {\n  return this % 2 === 0;\n};","parameters":{},"returns":{"type":"Boolean","description":"true if this number is an even integer, false otherwise."},"see":""},"odd":{"summary":"<p>Returns true if this number is odd (has remainder of 1 when divided by 2).</p>","code_sample":"<pre><code>2.odd()\n# =&gt; false\n\n3.odd()\n# =&gt; true\n\n0.odd()\n# =&gt; false\n</code></pre>","source":"Number.prototype.odd = function() {\n  if (this > 0) {\n    return this % 2 === 1;\n  } else {\n    return this % 2 === -1;\n  }\n};","parameters":{},"returns":{"type":"Boolean","description":"true if this number is an odd integer, false otherwise."},"see":""},"times":{"summary":"<p>Calls iterator the specified number of times, passing in the number of the<br />current iteration as a parameter: 0 on first call, 1 on the second call, etc.</p>","code_sample":"<pre><code>output = []\n\n5.times (n) -&gt;\n  output.push(n)\n\noutput\n# =&gt; [0, 1, 2, 3, 4]\n</code></pre>","source":"Number.prototype.times = function(iterator, context) {\n  var i;\n  i = -1;\n  while (++i < this) {\n    iterator.call(context, i);\n  }\n  return i;\n};","parameters":{"iterator":{"type":"Function","description":"The iterator takes a single parameter, the number of the current iteration.","optional":false},"context":{"type":"Object","description":"The optional context parameter specifies an object to treat as `this` in the iterator block.","optional":true}},"returns":{"type":"Number","description":"The number of times the iterator was called."},"see":""},"snap":{"summary":"<p>Returns the the nearest grid resolution less than or equal to the number.</p>","code_sample":"<pre><code>7.snap(8)\n# =&gt; 0\n\n4.snap(8)\n# =&gt; 0\n\n12.snap(8)\n# =&gt; 8\n</code></pre>","source":"Number.prototype.snap = function(resolution) {\n  var n;\n  n = this / resolution;\n  1 / 1;\n  return n.floor() * resolution;\n};","parameters":{"resolution":{"type":"Number","description":"The grid resolution to snap to.","optional":false}},"returns":{"type":"Number","description":"The nearest multiple of resolution lower than the number."},"see":""},"primeFactors":{"summary":"<p>In number theory, integer factorization or prime factorization is the<br />breaking down of a composite number into smaller non-trivial divisors,<br />which when multiplied together equal the original integer.</p>","code_sample":"<p>Floors the number for purposes of factorization.</p>\n\n<pre><code>60.primeFactors()\n# =&gt; [2, 2, 3, 5]\n\n37.primeFactors()\n# =&gt; [37]\n</code></pre>","source":"Number.prototype.primeFactors = function() {\n  var factors, i, iSquared, n;\n  factors = [];\n  n = Math.floor(this);\n  if (n === 0) return;\n  if (n < 0) {\n    factors.push(-1);\n    n /= -1;\n  }\n  i = 2;\n  iSquared = i * i;\n  while (iSquared < n) {\n    while ((n % i) === 0) {\n      factors.push(i);\n      n /= i;\n    }\n    i += 1;\n    iSquared = i * i;\n  }\n  if (n !== 1) factors.push(n);\n  return factors;\n};","parameters":{},"returns":{"type":"Array","description":"An array containing the factorization of this number."},"see":""},"toColorPart":{"summary":"<p>Returns the two character hexidecimal<br />representation of numbers 0 through 255.</p>","code_sample":"<pre><code>255.toColorPart()\n# =&gt; \"ff\"\n\n0.toColorPart()\n# =&gt; \"00\"\n\n200.toColorPart()\n# =&gt; \"c8\"\n</code></pre>","source":"Number.prototype.toColorPart = function() {\n  var s;\n  s = parseInt(this.clamp(0, 255), 10).toString(16);\n  if (s.length === 1) s = '0' + s;\n  return s;\n};","parameters":{},"returns":{"type":"String","description":"Hexidecimal representation of the number"},"see":""},"approach":{"summary":"<p>Returns a number that is maxDelta closer to target.</p>","code_sample":"<pre><code>255.approach(0, 5)\n# =&gt; 250\n\n5.approach(0, 10)\n# =&gt; 0\n</code></pre>","source":"Number.prototype.approach = function(target, maxDelta) {\n  return (target - this).clamp(-maxDelta, maxDelta) + this;\n};","parameters":{},"returns":{"type":"Number","description":"A number maxDelta toward target"},"see":""},"approachByRatio":{"summary":"<p>Returns a number that is closer to the target by the ratio.</p>","code_sample":"<pre><code>255.approachByRatio(0, 0.1)\n# =&gt; 229.5\n</code></pre>","source":"Number.prototype.approachByRatio = function(target, ratio) {\n  return this.approach(target, this * ratio);\n};","parameters":{},"returns":{"type":"Number","description":"A number toward target by the ratio"},"see":""},"approachRotation":{"summary":"<p>Returns a number that is closer to the target angle by the delta.</p>","code_sample":"<pre><code>Math.PI.approachRotation(0, Math.PI/4)\n# =&gt; 2.356194490192345 # this is (3/4) * Math.PI, which is (1/4) * Math.PI closer to 0 from Math.PI\n</code></pre>","source":"Number.prototype.approachRotation = function(target, maxDelta) {\n  while (target > this + Math.PI) {\n    target -= Math.TAU;\n  }\n  while (target < this - Math.PI) {\n    target += Math.TAU;\n  }\n  return (target - this).clamp(-maxDelta, maxDelta) + this;\n};","parameters":{},"returns":{"type":"Number","description":"A number toward the target angle by maxDelta"},"see":""},"constrainRotation":{"summary":"<p>Constrains a rotation to between -PI and PI.</p>","code_sample":"<pre><code>(9/4 * Math.PI).constrainRotation()\n# =&gt; 0.7853981633974483 # this is (1/4) * Math.PI\n</code></pre>","source":"Number.prototype.constrainRotation = function() {\n  var target;\n  target = this;\n  while (target > Math.PI) {\n    target -= Math.TAU;\n  }\n  while (target < -Math.PI) {\n    target += Math.TAU;\n  }\n  return target;\n};","parameters":{},"returns":{"type":"Number","description":"This number constrained between -PI and PI."},"see":""},"d":{"summary":"<p>The mathematical d operator. Useful for simulating dice rolls.</p>","code_sample":"<pre><code># Simulates rolling 5 6-sided dice\n5.d(6)\n\n# Simulates rolling 3 20-sided dice\n3.d(20)\n</code></pre>","source":"Number.prototype.d = function(sides) {\n  var sum;\n  sum = 0;\n  this.times(function() {\n    return sum += rand(sides) + 1;\n  });\n  return sum;\n};","parameters":{"sides":{"type":"Number","description":"Number of sides on the simulated die","optional":false}},"returns":{"type":"Number","description":"Sum of rolling `this` many `sides`-sided dice"},"see":""},"toExponential":{"summary":"<p>Returns a string representing the Number object in exponential notation</p>","code_sample":"<p><code><i>number</i>.toExponential( [<em>fractionDigits</em>] )</code></p>","source":null,"parameters":{"":{"type":"fractionDigits","description":"","optional":false}},"returns":{},"see":""},"toFixed":{"summary":"<p>Formats a number using fixed-point notation</p>","code_sample":"<p><code><i>number</i>.toFixed( [<em>digits</em>] )</code></p>","source":null,"parameters":{"The":{"type":"digits","description":"number of digits to appear after the decimal point; this","optional":false}},"returns":{},"see":""},"toLocaleString":{"summary":"<p>number.toLocaleString();</p>","code_sample":"","source":null,"parameters":{},"returns":{},"see":""},"toPrecision":{"summary":"<p>Returns a string representing the Number object to the specified precision.</p>","code_sample":"<p><code><em>number</em>.toPrecision( [ <em>precision</em> ] )</code></p>","source":null,"parameters":{"An":{"type":"precision","description":"integer specifying the number of significant digits.","optional":false}},"returns":{},"see":""},"toString":{"summary":"<p>Returns a string representing the specified Number object</p>","code_sample":"<p><code><i>number</i>.toString( [<em>radix</em>] )</code></p>","source":null,"parameters":{"":{"type":"radix","description":"","optional":false}},"returns":{},"see":""},"valueOf":{"summary":"<p>Returns the primitive value of a Number object.</p>","code_sample":"","source":null,"parameters":{},"returns":{},"see":""}}}},{"Object#":{"method_list":["hasOwnProperty"],"methods":{"hasOwnProperty":{"summary":"<p>Returns a boolean indicating whether the object has the specified property.</p>","code_sample":"<p><code><em>obj</em>.hasOwnProperty(<em>prop</em>)</code></p>","source":null,"parameters":{"The":{"type":"prop","description":"name of the property to test.","optional":false}},"returns":{},"see":""}}}},{"Object.":{"method_list":[],"methods":{}}},{"Oscillator.":{"method_list":[],"methods":{}}},{"Point#":{"method_list":["clamp","copy","add","add$","subtract","subtract$","scale","scale$","norm","norm$","floor","floor$","equal","length","magnitude","direction","dot","cross","distance"],"methods":{"clamp":{"summary":"<p>Constrain the magnitude of a vector.</p>","code_sample":"","source":"clamp: function(n) {\n      return this.copy().clamp$(n);\n    },\n    clamp$: function(n) {\n      if (this.magnitude() > n) {\n        return this.norm$(n);\n      } else {\n        return this;\n      }\n    },","parameters":{"n":{"type":"Number","description":"Maximum value for magnitude.","optional":false}},"returns":{"type":"Point","description":"A new point whose magnitude has been clamped to the given value."},"see":""},"copy":{"summary":"<p>Creates a copy of this point.</p>","code_sample":"","source":"copy: function() {\n      return Point(this.x, this.y);\n    },","parameters":{},"returns":{"type":"Point","description":"A new point with the same x and y value as this point."},"see":""},"add":{"summary":"<p>Adds a point to this one and returns the new point. You may<br />also use a two argument call like <code>point.add(x, y)</code><br />to add x and y values without a second point object.</p>","code_sample":"<pre><code>point = Point(2, 3).add(Point(3, 4))\n\npoint.x\n# =&gt; 5\n\npoint.y\n# =&gt; 7\n\nanotherPoint = Point(2, 3).add(3, 4)\n\nanotherPoint.x\n# =&gt; 5\n\nanotherPoint.y\n# =&gt; 7\n</code></pre>","source":"add: function(first, second) {\n      return this.copy().add$(first, second);\n    },","parameters":{"other":{"type":"Point","description":"The point to add this point to.","optional":false}},"returns":{"type":"Point","description":"A new point, the sum of both."},"see":""},"add$":{"summary":"<p>Adds a point to this one, returning a modified point. You may<br />also use a two argument call like <code>point.add(x, y)</code><br />to add x and y values without a second point object.</p>","code_sample":"<pre><code>point = Point(2, 3)\n\npoint.x\n# =&gt; 2\n\npoint.y\n# =&gt; 3\n\npoint.add$(Point(3, 4))\n\npoint.x\n# =&gt; 5\n\npoint.y\n# =&gt; 7\n\nanotherPoint = Point(2, 3)\nanotherPoint.add$(3, 4)\n\nanotherPoint.x\n# =&gt; 5\n\nanotherPoint.y\n# =&gt; 7\n</code></pre>","source":"add$: function(first, second) {\n      if (second != null) {\n        this.x += first;\n        this.y += second;\n      } else {\n        this.x += first.x;\n        this.y += first.y;\n      }\n      return this;\n    },","parameters":{"other":{"type":"Point","description":"The point to add this point to.","optional":false}},"returns":{"type":"Point","description":"The sum of both points."},"see":""},"subtract":{"summary":"<p>Subtracts a point to this one and returns the new point.</p>","code_sample":"<pre><code>point = Point(1, 2).subtract(Point(2, 0))\n\npoint.x\n# =&gt; -1\n\npoint.y\n# =&gt; 2\n\nanotherPoint = Point(1, 2).subtract(2, 0)\n\nanotherPoint.x\n# =&gt; -1\n\nanotherPoint.y\n# =&gt; 2\n</code></pre>","source":"subtract: function(first, second) {\n      return this.copy().subtract$(first, second);\n    },","parameters":{"other":{"type":"Point","description":"The point to subtract from this point.","optional":false}},"returns":{"type":"Point","description":"A new point, this - other."},"see":""},"subtract$":{"summary":"<p>Subtracts a point to this one and returns the new point.</p>","code_sample":"<pre><code>point = Point(1, 2)\n\npoint.x\n# =&gt; 1\n\npoint.y\n# =&gt; 2\n\npoint.subtract$(Point(2, 0))\n\npoint.x\n# =&gt; -1\n\npoint.y\n# =&gt; 2\n\nanotherPoint = Point(1, 2)\nanotherPoint.subtract$(2, 0)\n\nanotherPoint.x\n# =&gt; -1\n\nanotherPoint.y\n# =&gt; 2\n</code></pre>","source":"subtract$: function(first, second) {\n      if (second != null) {\n        this.x -= first;\n        this.y -= second;\n      } else {\n        this.x -= first.x;\n        this.y -= first.y;\n      }\n      return this;\n    },","parameters":{"other":{"type":"Point","description":"The point to subtract from this point.","optional":false}},"returns":{"type":"Point","description":"The difference of the two points."},"see":""},"scale":{"summary":"<p>Scale this Point (Vector) by a constant amount.</p>","code_sample":"<pre><code>point = Point(5, 6).scale(2)\n\npoint.x\n# =&gt; 10\n\npoint.y\n# =&gt; 12\n</code></pre>","source":"scale: function(scalar) {\n      return this.copy().scale$(scalar);\n    },","parameters":{"scalar":{"type":"Number","description":"The amount to scale this point by.","optional":false}},"returns":{"type":"Point","description":"A new point, this * scalar."},"see":""},"scale$":{"summary":"<p>Scale this Point (Vector) by a constant amount. Modifies the point in place.</p>","code_sample":"<pre><code>point = Point(5, 6)\n\npoint.x\n# =&gt; 5\n\npoint.y\n# =&gt; 6\n\npoint.scale$(2)\n\npoint.x\n# =&gt; 10\n\npoint.y\n# =&gt; 12\n</code></pre>","source":"scale$: function(scalar) {\n      this.x *= scalar;\n      this.y *= scalar;\n      return this;\n    },","parameters":{"scalar":{"type":"Number","description":"The amount to scale this point by.","optional":false}},"returns":{"type":"Point","description":"this * scalar."},"see":""},"norm":{"summary":"<p>The norm of a vector is the unit vector pointing in the same direction. This method<br />treats the point as though it is a vector from the origin to (x, y).</p>","code_sample":"<pre><code>point = Point(2, 3).norm()\n\npoint.x\n# =&gt; 0.5547001962252291\n\npoint.y\n# =&gt; 0.8320502943378437\n\nanotherPoint = Point(2, 3).norm(2)\n\nanotherPoint.x\n# =&gt; 1.1094003924504583\n\nanotherPoint.y\n# =&gt; 1.6641005886756874\n</code></pre>","source":"norm: function(length) {\n      if (length == null) length = 1.0;\n      return this.copy().norm$(length);\n    },","parameters":{},"returns":{"type":"Point","description":"The unit vector pointing in the same direction as this vector."},"see":""},"norm$":{"summary":"<p>The norm of a vector is the unit vector pointing in the same direction. This method<br />treats the point as though it is a vector from the origin to (x, y). Modifies the point in place.</p>","code_sample":"<pre><code>point = Point(2, 3).norm$()\n\npoint.x\n# =&gt; 0.5547001962252291\n\npoint.y\n# =&gt; 0.8320502943378437\n\nanotherPoint = Point(2, 3).norm$(2)\n\nanotherPoint.x\n# =&gt; 1.1094003924504583\n\nanotherPoint.y\n# =&gt; 1.6641005886756874\n</code></pre>","source":"norm$: function(length) {\n      var m;\n      if (length == null) length = 1.0;\n      if (m = this.length()) {\n        return this.scale$(length / m);\n      } else {\n        return this;\n      }\n    },","parameters":{},"returns":{"type":"Point","description":"The unit vector pointing in the same direction as this vector."},"see":""},"floor":{"summary":"<p>Floor the x and y values, returning a new point.</p>","code_sample":"<pre><code>point = Point(3.4, 5.8).floor()\n\npoint.x\n# =&gt; 3\n\npoint.y\n# =&gt; 5\n</code></pre>","source":"floor: function() {\n      return this.copy().floor$();\n    },","parameters":{},"returns":{"type":"Point","description":"A new point, with x and y values each floored to the largest previous integer."},"see":""},"floor$":{"summary":"<p>Floor the x and y values, returning a modified point.</p>","code_sample":"<pre><code>point = Point(3.4, 5.8)\npoint.floor$()\n\npoint.x\n# =&gt; 3\n\npoint.y\n# =&gt; 5\n</code></pre>","source":"floor$: function() {\n      this.x = this.x.floor();\n      this.y = this.y.floor();\n      return this;\n    },","parameters":{},"returns":{"type":"Point","description":"A modified point, with x and y values each floored to the largest previous integer."},"see":""},"equal":{"summary":"<p>Determine whether this point is equal to another point.</p>","code_sample":"<pre><code>pointA = Point(2, 3)\npointB = Point(2, 3)\npointC = Point(4, 5)\n\npointA.equal(pointB)\n# =&gt; true\n\npointA.equal(pointC)\n# =&gt; false\n</code></pre>","source":"equal: function(other) {\n      return this.x === other.x && this.y === other.y;\n    },","parameters":{"other":{"type":"Point","description":"The point to check for equality.","optional":false}},"returns":{"type":"Boolean","description":"true if the other point has the same x, y coordinates, false otherwise."},"see":""},"length":{"summary":"<p>Computed the length of this point as though it were a vector from (0,0) to (x,y).</p>","code_sample":"<pre><code>point = Point(5, 7)\n\npoint.length()\n# =&gt; 8.602325267042627\n</code></pre>","source":"length: function() {\n      return Math.sqrt(this.dot(this));\n    },","parameters":{},"returns":{"type":"Number","description":"The length of the vector from the origin to this point."},"see":""},"magnitude":{"summary":"<p>Calculate the magnitude of this Point (Vector).</p>","code_sample":"<pre><code>point = Point(5, 7)\n\npoint.magnitude()\n# =&gt; 8.602325267042627\n</code></pre>","source":"magnitude: function() {\n      return this.length();\n    },","parameters":{},"returns":{"type":"Number","description":"The magnitude of this point as if it were a vector from (0, 0) -> (x, y)."},"see":""},"direction":{"summary":"<p>Returns the direction in radians of this point from the origin.</p>","code_sample":"<pre><code>point = Point(0, 1)\n\npoint.direction()\n# =&gt; 1.5707963267948966 # Math.PI / 2\n</code></pre>","source":"direction: function() {\n      return Math.atan2(this.y, this.x);\n    },","parameters":{},"returns":{"type":"Number","description":"The direction in radians of this point from the origin"},"see":""},"dot":{"summary":"<p>Calculate the dot product of this point and another point (Vector).</p>","code_sample":"","source":"dot: function(other) {\n      return this.x * other.x + this.y * other.y;\n    },","parameters":{"other":{"type":"Point","description":"The point to dot with this point.","optional":false}},"returns":{"type":"Number","description":"The dot product of this point dot other as a scalar value."},"see":""},"cross":{"summary":"<p>Calculate the cross product of this point and another point (Vector).<br />Usually cross products are thought of as only applying to three dimensional vectors,<br />but z can be treated as zero. The result of this method is interpreted as the magnitude<br />of the vector result of the cross product between [x1, y1, 0] x [x2, y2, 0]<br />perpendicular to the xy plane.</p>","code_sample":"","source":"cross: function(other) {\n      return this.x * other.y - other.x * this.y;\n    },","parameters":{"other":{"type":"Point","description":"The point to cross with this point.","optional":false}},"returns":{"type":"Number","description":"The cross product of this point with the other point as scalar value."},"see":""},"distance":{"summary":"<p>Compute the Euclidean distance between this point and another point.</p>","code_sample":"<pre><code>pointA = Point(2, 3)\npointB = Point(9, 2)\n\npointA.distance(pointB)\n# =&gt; 7.0710678118654755 # Math.sqrt(50)\n</code></pre>","source":"distance: function(other) {\n      return Point.distance(this, other);\n    },","parameters":{"other":{"type":"Point","description":"The point to compute the distance to.","optional":false}},"returns":{"type":"Number","description":"The distance between this point and another point."},"see":""}}}},{"Point.":{"method_list":[],"methods":{}}},{"Random.":{"method_list":[],"methods":{}}},{"RegExp#":{"method_list":["exec","test","toString"],"methods":{"exec":{"summary":"<p>Executes a search for a match in a specified string. Returns a result array, or<br />null.</p>","code_sample":"","source":null,"parameters":{"The":{"type":"str","description":"string against which to match the regular expression.","optional":false}},"returns":{},"see":""},"test":{"summary":"<p>Executes the search for a match between a regular expression and a specified<br />string. Returns true or false.</p>","code_sample":"<p><code> <em>regexp</em>.test([<em>str</em>]) </code></p>","source":null,"parameters":{"The":{"type":"str","description":"string against which to match the regular expression.","optional":false}},"returns":{},"see":""},"toString":{"summary":"<p>Returns a string representing the specified object.</p>","code_sample":"<p><code><i>regexp</i>.toString()</code></p>","source":null,"parameters":{},"returns":{},"see":""}}}},{"ResourceLoader#":{"method_list":["urlFor"],"methods":{"urlFor":{"summary":"<p>Return the url for a particular asset.</p>","code_sample":"<pre><code>ResourceLoader.urlFor(\"images\", \"player\")\n# =&gt; This returns the url for the file \"player.png\" in your images directory.\n</code></pre>","source":"urlFor: function(directory, name) {\n      var type, _ref;\n      directory = (typeof App !== \"undefined\" && App !== null ? (_ref = App.directories) != null ? _ref[directory] : void 0 : void 0) || directory;\n      type = typeTable[directory];\n      return \"\" + BASE_URL + \"/\" + directory + \"/\" + name + \".\" + type + \"?\" + MTIME;\n    }\n  };\n  return (typeof exports !== \"undefined\" && exports !== null ? exports : this)[\"ResourceLoader\"] = ResourceLoader;\n})();\n;","parameters":{"directory":{"type":"String","description":"The directory your file is in.","optional":false},"name":{"type":"String","description":"The name of the file.","optional":false}},"returns":{"type":"String","description":"The full url of your asset"},"see":""}}}},{"Rotatable.":{"method_list":[],"methods":{}}},{"Sprite#":{"method_list":["draw","fill"],"methods":{"draw":{"summary":"<p>Draw this sprite on the given canvas at the given position.</p>","code_sample":"","source":"draw: function(canvas, x, y) {\n        return canvas.drawImage(image, sourceX, sourceY, width, height, x, y, width, height);\n      },","parameters":{"canvas":{"type":"PowerCanvas","description":"Reference to the canvas to draw the sprite on","optional":false},"x":{"type":"Number","description":"Position on the x axis to draw the sprite","optional":false},"y":{"type":"Number","description":"Position on the y axis to draw the sprite","optional":false}},"returns":{},"see":""},"fill":{"summary":"<p>Draw this sprite on the given canvas tiled to the x, y,<br />width, and height dimensions specified.</p>","code_sample":"","source":"fill: function(canvas, x, y, width, height, repeat) {\n        var pattern;\n        if (repeat == null) repeat = \"repeat\";\n        pattern = canvas.createPattern(image, repeat);\n        return canvas.drawRect({\n          x: x,\n          y: y,\n          width: width,\n          height: height,\n          color: pattern\n        });\n      },\n      width: width,\n      height: height\n    };\n  };","parameters":{"canvas":{"type":"PowerCanvas","description":"Reference to the canvas to draw the sprite on","optional":false},"x":{"type":"Number","description":"Position on the x axis to draw the sprite","optional":false},"y":{"type":"Number","description":"Position on the y axis to draw the sprite","optional":false},"width":{"type":"Number","description":"How far to tile the sprite on the x-axis","optional":false},"height":{"type":"Number","description":"How far to tile the sprite on the y-axis","optional":false},"repeat":{"type":"String","description":"Repeat options. Can be `repeat-x`, `repeat-y`, `no-repeat`, or `repeat`. Defaults to `repeat`","optional":false}},"returns":{},"see":""}}}},{"Sprite.":{"method_list":[],"methods":{}}},{"String#":{"method_list":["blank","camelize","capitalize","constantize","humanize","isString","parse","startsWith","titleize","underscore","withoutExtension","charAt","charCodeAt","concat","indexOf","lastIndexOf","localeCompare","match","replace","search","slice","split","substr","substring","toLocaleLowerCase","toLocaleUpperCase","toLowerCase","toString","toUpperCase","trim","valueOf"],"methods":{"blank":{"summary":"<p>Returns true if this string only contains whitespace characters.</p>","code_sample":"<pre><code>\"\".blank()\n# =&gt; true\n\n\"hello\".blank()\n# =&gt; false\n\n\"   \".blank()\n# =&gt; true\n</code></pre>","source":"String.prototype.blank = function() {\n  return /^\\s*$/.test(this);\n};","parameters":{},"returns":{"type":"Boolean","description":"Whether or not this string is blank."},"see":""},"camelize":{"summary":"<p>Returns a new string that is a camelCase version.</p>","code_sample":"<pre><code>\"camel_case\".camelize()\n\"camel-case\".camelize()\n\"camel case\".camelize()\n\n# =&gt; \"camelCase\"\n</code></pre>","source":"String.prototype.camelize = function() {\n  return this.trim().replace(/(\\-|_|\\s)+(.)?/g, function(match, separator, chr) {\n    if (chr) {\n      return chr.toUpperCase();\n    } else {\n      return '';\n    }\n  });\n};","parameters":{},"returns":{"type":"String","description":"A new string. camelCase version of `this`."},"see":""},"capitalize":{"summary":"<p>Returns a new string with the first letter capitalized and the rest lower cased.</p>","code_sample":"<pre><code>\"capital\".capitalize()\n\"cAPITAL\".capitalize()\n\"cApItAl\".capitalize()\n\"CAPITAL\".capitalize()\n\n# =&gt; \"Capital\"\n</code></pre>","source":"String.prototype.capitalize = function() {\n  return this.charAt(0).toUpperCase() + this.substring(1).toLowerCase();\n};","parameters":{},"returns":{"type":"String","description":"A new string. Capitalized version of `this`"},"see":""},"constantize":{"summary":"<p>Return the class or constant named in this string.</p>","code_sample":"<pre><code>\"Constant\".constantize()\n# =&gt; Constant\n# notice this isn't a string. Useful for calling methods on class with the same name as `this`.\n</code></pre>","source":"String.prototype.constantize = function() {\n  if (this.match(/[A-Z][A-Za-z0-9]*/)) {\n    eval(\"var that = \" + this);\n    return that;\n  } else {\n    throw \"String#constantize: '\" + this + \"' is not a valid constant name.\";\n  }\n};","parameters":{},"returns":{"type":"Object","description":"The class or constant named in this string."},"see":""},"humanize":{"summary":"<p>Returns a new string that is a more human readable version.</p>","code_sample":"<pre><code>\"player_id\".humanize()\n# =&gt; \"Player\"\n\n\"player_ammo\".humanize()\n# =&gt; \"Player ammo\"\n</code></pre>","source":"String.prototype.humanize = function() {\n  return this.replace(/_id$/, \"\").replace(/_/g, \" \").capitalize();\n};","parameters":{},"returns":{"type":"String","description":"A new string. Replaces _id and _ with \"\" and capitalizes the word."},"see":""},"isString":{"summary":"<p>Returns true.</p>","code_sample":"","source":"String.prototype.isString = function() {\n  return true;\n};","parameters":{},"returns":{"type":"Boolean","description":"true"},"see":""},"parse":{"summary":"<p>Parse this string as though it is JSON and return the object it represents. If it<br />is not valid JSON returns the string itself.</p>","code_sample":"<pre><code># this is valid json, so an object is returned\n'{\"a\": 3}'.parse()\n# =&gt; {a: 3}\n\n# double quoting instead isn't valid JSON so a string is returned\n\"{'a': 3}\".parse()\n# =&gt; \"{'a': 3}\"\n</code></pre>","source":"String.prototype.parse = function() {\n  try {\n    return JSON.parse(this.toString());\n  } catch (e) {\n    return this.toString();\n  }\n};","parameters":{},"returns":{"type":"Object","description":"Returns an object from the JSON this string contains. If it is not valid JSON returns the string itself."},"see":""},"startsWith":{"summary":"<p>Returns true if this string starts with the given string.</p>","code_sample":"","source":"String.prototype.startsWith = function(str) {\n  return this.lastIndexOf(str, 0) === 0;\n};","parameters":{"str":{"type":"String","description":"The string to check.","optional":false}},"returns":{"type":"Boolean","description":"True if this string starts with the given string, false otherwise."},"see":""},"titleize":{"summary":"<p>Returns a new string in Title Case.</p>","code_sample":"<pre><code>\"title-case\".titleize()\n# =&gt; \"Title Case\"\n\n\"title case\".titleize()\n# =&gt; \"Title Case\"\n</code></pre>","source":"String.prototype.titleize = function() {\n  return this.split(/[- ]/).map(function(word) {\n    return word.capitalize();\n  }).join(' ');\n};","parameters":{},"returns":{"type":"String","description":"A new string. Title Cased."},"see":""},"underscore":{"summary":"<p>Underscore a word, changing camelCased with under_scored.</p>","code_sample":"<pre><code>\"UNDERScore\".underscore()\n# =&gt; \"under_score\"\n\n\"UNDER-SCORE\".underscore()\n# =&gt; \"under_score\"\n\n\"UnDEr-SCorE\".underscore()\n# =&gt; \"un_d_er_s_cor_e\"\n</code></pre>","source":"String.prototype.underscore = function() {\n  return this.replace(/([A-Z]+)([A-Z][a-z])/g, '$1_$2').replace(/([a-z\\d])([A-Z])/g, '$1_$2').replace(/-/g, '_').toLowerCase();\n};","parameters":{},"returns":{"type":"String","description":"A new string. Separated by _."},"see":""},"withoutExtension":{"summary":"<p>Assumes the string is something like a file name and returns the<br />contents of the string without the extension.</p>","code_sample":"<pre><code>\"neat.png\".witouthExtension()\n# =&gt; \"neat\"\n</code></pre>","source":"String.prototype.withoutExtension = function() {\n  return this.replace(/\\.[^\\.]*$/, '');\n};\n\nString.prototype.parseHex = function() {\n  var alpha, hexString, i, rgb;\n  hexString = this.replace(/#/, '');\n  switch (hexString.length) {\n    case 3:\n    case 4:\n      if (hexString.length === 4) {\n        alpha = (parseInt(hexString.substr(3, 1), 16) * 0x11) / 255;\n      } else {\n        alpha = 1;\n      }\n      rgb = (function() {\n        var _results;\n        _results = [];\n        for (i = 0; i <= 2; i++) {\n          _results.push(parseInt(hexString.substr(i, 1), 16) * 0x11);\n        }\n        return _results;\n      })();\n      rgb.push(alpha);\n      return rgb;\n    case 6:\n    case 8:\n      if (hexString.length === 8) {\n        alpha = parseInt(hexString.substr(6, 2), 16) / 255;\n      } else {\n        alpha = 1;\n      }\n      rgb = (function() {\n        var _results;\n        _results = [];\n        for (i = 0; i <= 2; i++) {\n          _results.push(parseInt(hexString.substr(2 * i, 2), 16));\n        }\n        return _results;\n      })();\n      rgb.push(alpha);\n      return rgb;\n  }\n};\n;","parameters":{},"returns":{"type":"String","description":"A new string without the extension name."},"see":""},"charAt":{"summary":"<p>Returns the specified character from a string.</p>","code_sample":"<p><code><em>string</em>.charAt(<em>index</em>)</code></p>","source":null,"parameters":{"An":{"type":"index","description":"integer between 0 and 1 less than the length of the string.","optional":false}},"returns":{},"see":""},"charCodeAt":{"summary":"<p>Returns the numeric Unicode value of the character at the given index (except<br />for unicode codepoints > 0x10000).</p>","code_sample":"","source":null,"parameters":{"An":{"type":"index","description":"integer greater than 0 and less than the length of the string;","optional":false}},"returns":{},"see":""},"concat":{"summary":"<p>Combines the text of two or more strings and returns a new string.</p>","code_sample":"<p><code><em>string</em>.concat(<em>string2</em>, <em>string3</em>[, ..., <em>stringN</em>])</code></p>","source":null,"parameters":{"Strings":{"type":"string2...stringN","description":"to concatenate to this string.","optional":false}},"returns":{},"see":""},"indexOf":{"summary":"<p>Returns the index within the calling String object of the first occurrence of<br />the specified value, starting the search at fromIndex,<br />returns -1 if the value is not found.</p>","code_sample":"<p><code><em>string</em>.indexOf(<em>searchValue</em>[, <em>fromIndex</em>]</code></p>","source":null,"parameters":{"A":{"type":"searchValue","description":"string representing the value to search for.","optional":false},"The":{"type":"fromIndex","description":"location within the calling string to start the search","optional":false}},"returns":{},"see":""},"lastIndexOf":{"summary":"<p>Returns the index within the calling String object of the last occurrence of the<br />specified value, or -1 if not found. The calling string is searched backward,<br />starting at fromIndex.</p>","code_sample":"<p><code><em>string</em>.lastIndexOf(<em>searchValue</em>[, <em>fromIndex</em>])</code></p>","source":null,"parameters":{"A":{"type":"searchValue","description":"string representing the value to search for.","optional":false},"The":{"type":"fromIndex","description":"location within the calling string to start the search","optional":false}},"returns":{},"see":""},"localeCompare":{"summary":"<p>Returns a number indicating whether a reference string comes before or after or<br />is the same as the given string in sort order.</p>","code_sample":"<p><code> localeCompare(compareString) </code></p>","source":null,"parameters":{},"returns":{},"see":""},"match":{"summary":"<p>Used to retrieve the matches when matching a string against a regular<br />expression.</p>","code_sample":"<p><code><em>string</em>.match(<em>regexp</em>)</code></p>","source":null,"parameters":{"A":{"type":"regexp","description":"regular expression object. If a non-RegExp object obj is passed,","optional":false}},"returns":{},"see":""},"replace":{"summary":"<p>Returns a new string with some or all matches of a pattern replaced by a<br />replacement.  The pattern can be a string or a RegExp, and the replacement can<br />be a string or a function to be called for each match.</p>","code_sample":"<p><code><em>str</em>.replace(<em>regexp|substr</em>, <em>newSubStr|function[</em>, </code><code><em>flags]</em>);</code></p>","source":null,"parameters":{"A":{"type":"function","description":"function to be invoked to create the new substring (to put in","optional":false},"The":{"type":"newSubStr","description":"String that replaces the substring received from parameter","optional":false},"gimy":{"type":"flags","description":"","optional":false}},"returns":{},"see":""},"search":{"summary":"<p>Executes the search for a match between a regular expression and this String<br />object.</p>","code_sample":"<p><code><em>string</em>.search(<em>regexp</em>)</code></p>","source":null,"parameters":{"A":{"type":"regexp","description":"regular expression object. If a non-RegExp object obj is","optional":false}},"returns":{},"see":""},"slice":{"summary":"<p>Extracts a section of a string and returns a new string.</p>","code_sample":"<p><code><em>string</em>.slice(<em>beginslice</em>[, <em>endSlice</em>])</code></p>","source":null,"parameters":{"The":{"type":"endSlice","description":"zero-based index at which to end extraction. If omitted,","optional":false}},"returns":{},"see":""},"split":{"summary":"<p>Splits a String object into an array of strings by separating the string into<br />substrings.</p>","code_sample":"<p><code><em>string</em>.split([<em>separator</em>][, <em>limit</em>])</code></p>","source":null,"parameters":{"Specifies":{"type":"separator","description":"the character to use for separating the string. The","optional":false},"Integer":{"type":"limit","description":"specifying a limit on the number of splits to be found.","optional":false}},"returns":{},"see":""},"substr":{"summary":"<p>Returns the characters in a string beginning at the specified location through<br />the specified number of characters.</p>","code_sample":"<p><code><em>string</em>.substr(<em>start</em>[, <em>length</em>])</code></p>","source":null,"parameters":{"Location":{"type":"start","description":"at which to begin extracting characters.","optional":false},"The":{"type":"length","description":"number of characters to extract.","optional":false}},"returns":{},"see":""},"substring":{"summary":"<p>Returns a subset of a string between one index and another, or through the end<br />of the string.</p>","code_sample":"<p><code><em>string</em>.substring(<em>indexA</em>[, <em>indexB</em>])</code></p>","source":null,"parameters":{"An":{"type":"indexA","description":"integer between 0 and one less than the length of the string.","optional":false},"(optional)":{"type":"indexB","description":"An integer between 0 and the length of the string.","optional":false}},"returns":{},"see":""},"toLocaleLowerCase":{"summary":"<p>Returns the calling string value converted to lower case, according to any<br />locale-specific case mappings.</p>","code_sample":"<p><code> toLocaleLowerCase() </code></p>","source":null,"parameters":{},"returns":{},"see":""},"toLocaleUpperCase":{"summary":"<p>Returns the calling string value converted to upper case, according to any<br />locale-specific case mappings.</p>","code_sample":"<p><code> toLocaleUpperCase() </code></p>","source":null,"parameters":{},"returns":{},"see":""},"toLowerCase":{"summary":"<p>Returns the calling string value converted to lowercase.</p>","code_sample":"<p><code><em>string</em>.toLowerCase()</code></p>","source":null,"parameters":{},"returns":{},"see":""},"toString":{"summary":"<p>Returns a string representing the specified object.</p>","code_sample":"<p><code><em>string</em>.toString()</code></p>","source":null,"parameters":{},"returns":{},"see":""},"toUpperCase":{"summary":"<p>Returns the calling string value converted to uppercase.</p>","code_sample":"<p><code><em>string</em>.toUpperCase()</code></p>","source":null,"parameters":{},"returns":{},"see":""},"trim":{"summary":"<p>Removes whitespace from both ends of the string.</p>","code_sample":"<p><code><em>string</em>.trim()</code></p>","source":null,"parameters":{},"returns":{},"see":""},"valueOf":{"summary":"<p>Returns the primitive value of a String object.</p>","code_sample":"<p><code><em>string</em>.valueOf()</code></p>","source":null,"parameters":{},"returns":{},"see":""}}}},{"TextEffect#":{"method_list":["update","draw"],"methods":{"update":{"summary":"<p>Updates the position of the text based on the effect velocity. Updates the<br />alpha based on the elapsed time since the effect creation. If <code>rotationalVelocity</code><br />is provided then the text rotation is updated as well.</p>","code_sample":"","source":null,"parameters":{},"returns":{},"see":""},"draw":{"summary":"<p>Draws the <code>textShadow</code> text and the <code>text</code> text.</p>","code_sample":"","source":"var TextEffect;\n\nTextEffect = function(I) {\n  var self;\n  if (I == null) I = {};\n  Object.reverseMerge(I, {\n    color: Color('green'),\n    duration: 40,\n    font: '20px Helvetica',\n    text: '100',\n    textShadow: Color('black'),\n    alpha: 1,\n    rotation: 0,\n    rotationalVelocity: 0,\n    velocity: Point(0, -1)\n  });\n  self = GameObject(I);\n  self.bind(\"update\", function() {\n    I.rotation += I.rotationalVelocity;\n    I.x += I.velocity.x;\n    I.y += I.velocity.y;\n    return I.alpha = 1 - (I.age / I.duration);\n  });\n  self.unbind(\"draw\");\n  self.bind(\"draw\", function(canvas) {\n    if (!I.color.channels) I.color = Color(I.color);\n    if (!I.textShadow.channels) I.textShadow = Color(I.textShadow);\n    I.color.a = I.alpha;\n    I.textShadow.a = I.alpha;\n    canvas.font(I.font);\n    canvas.drawText({\n      color: I.textShadow,\n      x: 1,\n      y: 1,\n      text: I.text\n    });\n    return canvas.drawText({\n      color: I.color,\n      x: 0,\n      y: 0,\n      text: I.text\n    });\n  });\n  return self;\n};\n;","parameters":{"canvas":{"type":"PixieCanvas","description":"","optional":false}},"returns":{},"see":""}}}},{"TextEffect.":{"method_list":[],"methods":{}}},{"TextScreen#":{"method_list":["centerText"],"methods":{"centerText":{"summary":"<p>Draw center aligned text at the given y position.</p>","code_sample":"<pre><code>screen = TextScreen()\nscreen.centerText canvas, 'Centering text is easy'\n</code></pre>","source":"centerText: function(canvas, text, options) {\n      var color, font, size, yPosition;\n      if (options == null) options = {};\n      font = options.font || I.font;\n      size = options.size || I.fontSize;\n      color = options.color || I.fontColor;\n      yPosition = options.y || I.yPosition;\n      canvas.font(\"\" + size + \"px \" + font);\n      return canvas.centerText({\n        y: yPosition,\n        text: text,\n        color: color\n      });\n    }\n  });\n};\n;\n\n(function() {\n  var Map, Tilemap, loadByName;\n  Map = function(data, entityCallback) {\n    var entity, loadEntities, spriteLookup, tileHeight, tileWidth, uuid, _ref;\n    tileHeight = data.tileHeight;\n    tileWidth = data.tileWidth;\n    spriteLookup = {};\n    _ref = App.entities;\n    for (uuid in _ref) {\n      entity = _ref[uuid];\n      spriteLookup[uuid] = Sprite.fromURL(entity.tileSrc);\n    }\n    loadEntities = function() {\n      if (!entityCallback) return;\n      return data.layers.each(function(layer, layerIndex) {\n        var instance, instanceData, instances, x, y, _i, _len, _results;\n        if (instances = layer.instances) {\n          _results = [];\n          for (_i = 0, _len = instances.length; _i < _len; _i++) {\n            instance = instances[_i];\n            x = instance.x, y = instance.y, uuid = instance.uuid;\n            instanceData = Object.extend({\n              layer: layerIndex,\n              sprite: spriteLookup[uuid],\n              x: x + tileWidth / 2,\n              y: y + tileHeight / 2\n            }, App.entities[uuid], instance.properties);\n            _results.push(entityCallback(instanceData));\n          }\n          return _results;\n        }\n      });\n    };\n    loadEntities();\n    return data;\n  };\n  Tilemap = function(name, callback, entityCallback) {\n    return fromPixieId(App.Tilemaps[name], callback, entityCallback);\n  };\n  loadByName = function(name, callback, entityCallback) {\n    var proxy, url;\n    url = ResourceLoader.urlFor(\"tilemaps\", name);\n    proxy = {};\n    $.getJSON(url, function(data) {\n      Object.extend(proxy, Map(data, entityCallback));\n      return typeof callback === \"function\" ? callback(proxy) : void 0;\n    });\n    return proxy;\n  };\n  Tilemap.load = function(options) {\n    if (options.pixieId) {\n      return fromPixieId(options.pixieId, options.complete, options.entity);\n    } else if (options.name) {\n      return loadByName(options.name, options.complete, options.entity);\n    }\n  };\n  return (typeof exports !== \"undefined\" && exports !== null ? exports : this)[\"Tilemap\"] = Tilemap;\n})();\n;","parameters":{"canvas":{"type":"PixieCanvas","description":"The canvas to draw on","optional":false},"text":{"type":"String","description":"The text to draw","optional":false},"options":{"type":"Object","description":"These include font, size, color, and yPosition","optional":false}},"returns":{},"see":""}}}},{"TextScreen.":{"method_list":[],"methods":{}}},{"TimedEvents#":{"method_list":["every"],"methods":{"every":{"summary":"<p>Execute <code>fn</code> every <code>n</code> frames.</p>","code_sample":"<pre><code>player = GameObject()\n\nplayer.include TimedEvents\n\n# doSomething is called every 4 frames\nplayer.every 4, -&gt;\n  doSomething()\n</code></pre>","source":"every: function(n, fn) {\n      if (I.age.mod(n) === 0) return fn();\n    }\n  };\n};\n;","parameters":{"n":{"type":"Number","description":"Number of frames to wait before executing the callback","optional":false},"fn":{"type":"Function","description":"Code to execute after `n` frames has passed","optional":false}},"returns":{},"see":""}}}},{"TimedEvents.":{"method_list":[],"methods":{}}},{"TitleScreen#":{"method_list":["update","overlay"],"methods":{"update":{"summary":"<p>Goes to the next level on any user input.</p>","code_sample":"","source":null,"parameters":{},"returns":{},"see":""},"overlay":{"summary":"<p>Overlays the title text in the middle of the screen. Uses <code>App.name</code></p>","code_sample":"","source":"var TitleScreen;\n\nTitleScreen = function(I) {\n  var self;\n  if (I == null) I = {};\n  self = TextScreen(I);\n  self.bind('update', function() {\n    if (justPressed.any) return engine.nextLevel();\n  });\n  self.bind(\"overlay\", function(canvas) {\n    self.centerText(canvas, App.name);\n    return self.centerText(canvas, \"Press any key to start\", {\n      size: 12,\n      y: App.height / 2 + 30\n    });\n  });\n  return self;\n};\n;","parameters":{"canvas":{"type":"PixieCanvas","description":"","optional":false}},"returns":{},"see":""}}}},{"TitleScreen.":{"method_list":[],"methods":{}}},{"Tween#":{"method_list":["tween"],"methods":{"tween":{"summary":"<p>Modify the object's properties over time.</p>","code_sample":"<pre><code>player = GameObject()\n\nplayer.tween 30,\n  x: 50\n  y: 50\n  easing: \"quadratic\"\n\nplayer = GameObject()\n\nplayer.tween 30,\n  x: 150\n  y: 150\n  complete: -&gt;\n    player.dance()\n</code></pre>","source":"tween: function(duration, properties) {\n      var complete, easing, property, target, _results;\n      properties = Object.extend({}, properties);\n      easing = properties.easing || \"linear\";\n      complete = properties.complete;\n      delete properties.easing;\n      delete properties.complete;\n      _results = [];\n      for (property in properties) {\n        target = properties[property];\n        _results.push(I.activeTweens[property] = {\n          complete: complete,\n          end: target,\n          start: I[property],\n          easing: easing,\n          duration: duration,\n          startTime: I.age,\n          endTime: I.age + duration\n        });\n      }\n      return _results;\n    }\n  };\n};\n;\n;","parameters":{"duration":{"type":"Number","description":"How long (in frames) until the object's properties reach their final values.","optional":false},"properties":{"type":"Object","description":"Which properties to tween. Set the `easing` property to specify the easing function.","optional":false}},"returns":{},"see":""}}}},{"Tween.":{"method_list":[],"methods":{}}},{"window.":{"method_list":[],"methods":{}}}]